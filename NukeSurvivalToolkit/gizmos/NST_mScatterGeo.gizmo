Group {
 name mScatterGeo
 onCreate "\nnuke.thisGroup()\['max_instance'].setFlag(0x00000100)\n"
 tile_color 0x194e7fff
 note_font Verdana
 addUserKnob {20 general}
 addUserKnob {26 title_snap l "<b>SNAP SETUP</b>"}
 addUserKnob {41 snap_type l "snap type" t "<u>selected vertices/faces</u>\nCreate instance(s) from selected vertices/faces. 'RGB texture' sampling does not support this snap type.\n\n<u>density map (alpha)</u>\nUse alpha channel of sampleGeo as density map. 'RGB texture' sampling supported this snap type." T menu02.snap_type}
 addUserKnob {26 title_vf_setting l "<b>vertices/faces setting</b>"}
 addUserKnob {7 random_percentage l "random percentage" t "Setup the percentage of the random will apply. The value clipped between 0 to 100." R 0.01 100}
 random_percentage 100
 addUserKnob {3 random_seed l seed}
 addUserKnob {26 title_dmap_setting l "<b>density map setting</b>" +DISABLED}
 addUserKnob {4 uv_type l UV t "<u>single tile</u>\nprocess faster.\n\n<u>udim</u>\nwill scan through all the UV tiles before process.\n\n*if not sure what type of UV set in geo, recommend to use 'udim' to scan through all the tiles. Or use my another tool, 'UVEditor', to check." +DISABLED M {"single tile (fast)" udim "" "" "" "" "" "" ""}}
 addUserKnob {3 sample_res l "sample resolution" t "This resolution setting to control the spacing between each instance. Higher solution will get more sample points in UV. Lower solution will get less sample points in UV." -STARTLINE +DISABLED}
 sample_res 1024
 addUserKnob {78 max_instance l "max instance(s)" t "This can control the maximun instance(s) will be generated, to speed up the process if user only need to generate few instance(s)." +DISABLED n 1}
 max_instance 1000
 addUserKnob {3 dmap_seed l seed -STARTLINE +DISABLED}
 addUserKnob {3 fail_attempts l "fail attempts" t "set how many times to retry if they fail on sampling. When max instances are larger than available samples, then the sample process will fall into a loop hole. So value limited the retry attempts.\n\n\n- lower value can get faster but may not meet the max instances value.\n\n\n- higher value can meet the max instance value but might take longer time to retry the sampling.\n\n\nWhat makes the sampling fail?\nposition+range size already existing in the sample data.\n\n" +DISABLED}
 fail_attempts 500
 addUserKnob {4 rgb_color l "RGB texture color" t "Sample color from 'sampleGeo' texture input and generated with instance(s).\n\n<u>sample premult RGB</u>\nsemi-transparent pixels will get darker color on generated instance, but the color is 100% match to the sampled texture color.\n\n<u>sample unpremult RGB</u>\nThis can avoid dark color on semi-transparent pixels." +DISABLED M {"not selected" "sample premult RGB" "sample unpremult RGB" "" "" ""}}
 addUserKnob {26 spacer l "" +STARTLINE T <br>}
 addUserKnob {26 title_rotate l "<b>ROTATION SETUP</b>"}
 addUserKnob {4 rotation_type l type t "Rotation type of the snap geo.\n\n<u>lookAt axis/camera</u>\ninstance rotation base on the input axis/camera direction. Axis/Camera input will be created in the generate group.\n\n<u>face normal</u>\ninstance rotation base on the geo surface." M {"lookAt axis/camera" "vertices/faces normal" "" "" "" "" ""}}
 rotation_type "vertices/faces normal"
 addUserKnob {26 title_input l "<b>INPUT SETUP</b>"}
 addUserKnob {41 var_type l "variation type" t "select the input variation type.\n\n<u>Framehold</u>\nrandom pick a still frame of texture & geo.\n\n<u>Timeoffset</u>\nrandom pick the start frame of texture sequence and animated geo." T menu01.var_type}
 addUserKnob {3 frame_start l "frame range"}
 frame_start 1001
 addUserKnob {3 frame_end l "" -STARTLINE}
 frame_end 1100
 addUserKnob {3 offset_start l "offset range" +HIDDEN}
 offset_start -20
 addUserKnob {3 offset_end l "" -STARTLINE +HIDDEN}
 offset_end 20
 addUserKnob {26 spacer_3 l "" +STARTLINE T <br>}
 addUserKnob {22 generate l "<b>\[--- GENERATE ---]</b>" t "Generate group named 'mSnap'" T "thisGRP = nuke.thisGroup()\n\ntry :\n\t##### get functions\n\tgoStore = nuke.toNode('store')\n\tgoStore\['fn01'].execute()\n\tgoStore\['fn02'].execute()\n\n\tfilterCheck = goStore\['filterNonReverse'].getValue().split(',')\n\tfilter3DNodes = goStore\['filter3DNodes'].value().split(',')\n\tfilterPrimitives = goStore\['filterPrimitives'].value().split(',')\n\n\tif thisGRP\['snap_type'].getValue() :\n\t\t##### density map type\n\t\tuvStart = nuke.toNode('uv_dot')\n\t\t##### remove prep nodes\n\t\trmNodes( uvStart )\n\n\t\tcurveTool = nuke.toNode('CurveTool')\n\t\ttexRes = int( thisGRP\['sample_res'].value() )\n\t\tmaxIns = thisGRP\['max_instance'].getValue()\n\n\t\tif texRes > 32 :\n\t\t\t##### find map data on tile\n\t\t\tsamNodes = scanTile( thisGRP, uvStart, curveTool, texRes )\n\n\t\t\tif len(samNodes) :\n\t\t\t\t##### find the sum of area\n\t\t\t\ttotalArea = 0\n\t\t\t\tfor samNode in samNodes :\n\t\t\t\t\ttotalArea += samNode.width() * samNode.height()\n\n\t\t\t\tif maxIns < totalArea :\n\t\t\t\t\t##### find tile proportion\n\t\t\t\t\ttileData = \{\}\n\t\t\t\t\tfor samNode in samNodes :\n\t\t\t\t\t\tsamCount = int( round( ( samNode.width() * samNode.height() ) / totalArea * maxIns ) )\n\t\t\t\t\t\ttileData\[samNode.name()] = \[ samNode, samCount ]\n\n\t\t\t\t\t##### process\n\t\t\t\t\tptsID = samID( thisGRP ,  tileData )\n\n\t\t\t\t\tif thisGRP\['with_animation'].value() :\n\t\t\t\t\t\t##### snap with animation\n\t\t\t\t\t\tprojRange = str( int( nuke.root()\['first_frame'].getValue() ) ) + '-' + str( int( nuke.root()\['last_frame'].getValue() ) )\n\t\t\t\t\t\tp = nuke.Panel('frame range')\n\t\t\t\t\t\tp.addSingleLineInput('set frame range', projRange)\n\t\t\t\t\t\tif p.show() == 1 :\n\t\t\t\t\t\t\tcrange = p.value('set frame range').replace(' ', '')\n\t\t\t\t\t\t\tif '-' in crange :\n\t\t\t\t\t\t\t\tfRNG = \[ int( crange.split('-')\[0] ) , int( crange.split('-')\[1] ) ]\n\t\t\t\t\t\t\t\tgenDMap( thisGRP , ptsID , samNodes , fRNG )\n\t\t\t\t\telse :\n\t\t\t\t\t\tgenDMap( thisGRP , ptsID , samNodes )\n\n\t\t\t\t\t##### remove prep nodes\n\t\t\t\t\trmNodes( uvStart )\n\t\t\t\telse :\n\t\t\t\t\tnuke.message(\"'max instance(s)'' <font color='red'>larger</font> than detected sample area.<br><br>Try to <font color=orange>reduce</font> 'max instance(s)' or <font color=orange>increase</font> 'sample resolution' to process again.<br><br>Process denied...\")\n\t\t\t\t\t##### remove prep nodes\n\t\t\t\t\trmNodes( uvStart )\n\t\t\telse :\n\t\t\t\tnuke.message('No UV data detected.<br><br>Process denied...')\n\t\telse :\n\t\t\tnuke.message('sample resolution cannot set lower than 32.<br><br>Process denied...')\n\telse :\n\t\t##### selected vertices/faces type\n\t\tmainstream = upstreamNodes( thisGRP , filter3DNodes )\n\n\t\tdisabledNodes = \[]\n\t\tfor lvl01 in mainstream :\n\t\t\tfor lvl02 in lvl01 :\n\t\t\t\tif lvl02\['disable'].getValue() :\n\t\t\t\t\tdisabledNodes.append( lvl02.name() )\n\n\t\t##### check disable nodes\n\t\tif len( disabledNodes ) :\n\t\t\tnuke.message( 'Disabled node(s) :<p><font color=red>\{0\}</font><p>Please disconnect these transformation nodes from the tree.<br><br>Process denied...'.format( '<br>'.join(disabledNodes) ) )\n\n\t\telse :\n\t\t\tif failCHK( thisGRP , \['EditGeo','ProcGeo'] ) :\n\t\t\t\tnuke.message(\"<font color=orange>'EditGeo' & 'ProceduralNoise'</font> detected in upstream which are not support 'selected vertices/faces' at this moment.<br><br>Recommend to use 'WriteGeo' export it, and then bring it back with 'ReadGeo to process, or use density map.<br><br>Process denied...\")\n\t\t\telse :\n\t\t\t\t##### find primary geo\n\t\t\t\tmainGeo = primaryGeo( mainstream , filterPrimitives )\n\n\t\t\t\t##### get selected ID\n\t\t\t\tptsID = selID()\n\n\t\t\t\tif len( ptsID ) == 0 :\n\t\t\t\t\tfacesVTX = \[]\n\t\t\t\t\tfor key,value in enumerate( mainGeo\['geo_select'].getSelectedFaces()\[0] ) :\n\t\t\t\t\t\tif value :\n\t\t\t\t\t\t\tfacesVTX.append( geoPrims( mainGeo )\[key] )\n\t\t\t\t\tptsID = facesVTX\n\t\t\t\t\tselType = 'face'\n\t\t\t\telse :\n\t\t\t\t\tselType = 'vertex'\n\t\t\t\t\tif thisGRP\['rotation_type'].getValue() :\n\t\t\t\t\t\tif mainGeo.Class() == 'ReadGeo' or mainGeo.Class() == 'ReadGeo2' :\n\t\t\t\t\t\t\tif nuke.ask(\"vertex normal on 'ReadGeo' might wonky in some certain cases.<br><br><font color=orange>'ok'</font> - to keep rotate by vertex normal.<br><font color=orange>'cancel'</font> - rotate by faces normal instead.\") :\n\t\t\t\t\t\t\t\tselType = 'vertex'\n\t\t\t\t\t\t\telse :\n\t\t\t\t\t\t\t\tselType = 'vertexFaces'\n\n\t\t\t\t##### random selection\n\t\t\t\tptsID = randSelID( ptsID , thisGRP )\n\n\t\t\t\t##### snap vertex\n\t\t\t\tif ptsID :\n\n\t\t\t\t\tif thisGRP\['rotation_type'].getValue() :\n\t\t\t\t\t\tgonType = len( nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives() )\n\n\t\t\t\t\tif thisGRP\['with_animation'].value() :\n\t\t\t\t\t\t##### snap with animation\n\t\t\t\t\t\tprojRange = str( int( nuke.root()\['first_frame'].getValue() ) ) + '-' + str( int( nuke.root()\['last_frame'].getValue() ) )\n\t\t\t\t\t\tp = nuke.Panel('frame range')\n\t\t\t\t\t\tp.addSingleLineInput('set frame range', projRange)\n\t\t\t\t\t\tif p.show() == 1 :\n\t\t\t\t\t\t\tcrange = p.value('set frame range').replace(' ', '')\n\t\t\t\t\t\t\tif '-' in crange :\n\t\t\t\t\t\t\t\tfRNG = \[ int( crange.split('-')\[0] ) , int( crange.split('-')\[1] ) ]\n\n\t\t\t\t\t\t\t\t##### Rotation Type\n\t\t\t\t\t\t\t\tif thisGRP\['rotation_type'].getValue() :\n\n\t\t\t\t\t\t\t\t\tif gonType > 1 :\n\t\t\t\t\t\t\t\t\t\t##### tris with animation\n\t\t\t\t\t\t\t\t\t\tgenFaceNor( thisGRP, mainstream, mainGeo, ptsID, selType, fRNG )\n\t\t\t\t\t\t\t\t\telse :\n\t\t\t\t\t\t\t\t\t\t##### quads with animation\n\t\t\t\t\t\t\t\t\t\tgenFaceNor( thisGRP, mainstream, mainGeo, ptsID, selType, fRNG )\n\n\t\t\t\t\t\t\t\telse :\n\t\t\t\t\t\t\t\t\tgenSelVtx( thisGRP, mainstream, ptsID, selType, fRNG )\n\n\t\t\t\t\t\t\telse :\n\t\t\t\t\t\t\t\t##### message of incorrect frame range format\n\t\t\t\t\t\t\t\tnuke.message('Frame range format incorrect.<br>It should be :<br>\[start frame]-\[last frame]<br>spacing allowed.<br><br>e.g.<br>1001-1100<br>1001 - 1100')\n\n\t\t\t\t\telse :\n\n\t\t\t\t\t\t##### snap static\n\t\t\t\t\t\tif thisGRP\['rotation_type'].getValue() :\n\t\t\t\t\t\t\tif gonType > 1 :\n\t\t\t\t\t\t\t\t##### tris static\n\t\t\t\t\t\t\t\tgenFaceNor( thisGRP, mainstream, mainGeo, ptsID, selType )\n\t\t\t\t\t\t\telse :\n\t\t\t\t\t\t\t\t##### quads static\n\t\t\t\t\t\t\t\tgenFaceNor( thisGRP, mainstream, mainGeo, ptsID, selType )\n\n\t\t\t\t\t\telse :\n\t\t\t\t\t\t\tgenSelVtx( thisGRP, mainstream, ptsID, selType )\n\n\t\t\t\telse :\n\t\t\t\t\tnuke.message( 'Please select <font color=orange>vertex/face</font> to start.' )\n\nexcept UnboundLocalError :\n\tnuke.message('No available input found. Input required 3D geo.<br><br>Process denied...')" +STARTLINE}
 addUserKnob {6 with_animation l "with animated geo" -STARTLINE}
 addUserKnob {26 ""}
 addUserKnob {22 selected_vertex_info l "selected vertex info" t "get the vertices/faces info." T "thisGRP = nuke.thisGroup()\npyg = nuke.toNode('PythonGeo')\n\n##### get functions\ngoStore = nuke.toNode('store')\ngoStore\['fn01'].execute()\ngoStore\['fn02'].execute()\n\nfilter3DNodes = goStore\['filter3DNodes'].value().split(',')\nfilterPrimitives = goStore\['filterPrimitives'].value().split(',')\n\nmainstream = upstreamNodes( thisGRP , filter3DNodes )\n\ndisabledNodes = \[]\nfor lvl01 in mainstream :\n  for lvl02 in lvl01 :\n    if lvl02\['disable'].getValue() :\n      disabledNodes.append( lvl02.name() )\n\n##### check disable nodes\nif len( disabledNodes ) :\n  nuke.message( 'Disabled node(s) :<p><font color=red>\{0\}</font><p>Please disconnect these transformation nodes from the tree.'.format( '<br>'.join(disabledNodes) ) )\n\nelse :\n  ##### find primary geo\n  mainGeo = primaryGeo( mainstream , filterPrimitives )\n\n  ##### get selected ID\n  ptsID = selID()\n\n  if len( ptsID ) == 0 :\n    facesVTX = \[]\n    for key,value in enumerate( mainGeo\['geo_select'].getSelectedFaces()\[0] ) :\n      if value :\n        facesVTX.append( geoPrims( mainGeo )\[key] )\n    ptsID = facesVTX\n    selType = 1\n  else :\n    selType = 0\n\n  ptsID = randSelID( ptsID , thisGRP )\n\n  gData = geoData( pyg , 0 ) ##### get geo data\n\n  info = \['<b><font color=orange>geo total vertex : </font></b>' + str( len(gData) ) , '<b><font color=orange>total selected vertex : </font></b>' + str( len(ptsID) ) , '' ]\n  print ('total vertex : ' + str(len(gData)))\n  for i in ptsID :\n    if type(i) == str :\n      info.append( '<b><font color=orange>selected geo type : </font></b>vertex' )\n      info.append( '<b><font color=orange>primitives : </font></b>' + str( i.split('_')\[1:]\[0] ) )\n      info.append( '<b><font color=orange>vertex (pos|nor) : </font></b>' + str( gData\[i] ) )\n    else :\n      if len(i) == 3 :\n        info.append( '<b><font color=orange>selected geo type : </font></b>3-sides' )\n      elif len(i) == 4 :\n        info.append( '<b><font color=orange>selected geo type : </font></b>4-sides' )\n      else :\n        info.append( '<b><font color=orange>selected geo type : </font></b>N-sides' )\n\n      for prim in i :\n        info.append( '<b><font color=orange>vertex ID : </font></b>' + str( prim ) )\n        info.append( '<b><font color=orange>vertex (pos|nor) : </font></b>' + str( gData\['0_' + str( prim )] ) )\n\n    info.append( '' )\n    info.append( '===================' )\n    info.append( '' )\n\np = nuke.Panel( 'Selected vertex info :' )\np.addNotepad( '', '<br>'.join( info ) )\np.setWidth(1200)\np.show()" +STARTLINE}
 addUserKnob {26 title_selection l "<i>( optional )</i>" T "<b>save selected vertices / faces</b>"}
 addUserKnob {41 geo T GeoSelect.geo}
 addUserKnob {22 save_selection l "save selection" T "if nuke.thisGroup().inputs() :\n\tnuke.thisGroup()\['hidden_btn'].execute()\n\tnuke.thisGroup()\['savedata'].setValue( nuke.thisGroup()\['geo'].toScript() )\nelse :\n\tnuke.message('Save selection fail.<br>No inputs found.<br>Please connect this node to geo.')" +STARTLINE}
 addUserKnob {41 hidden_btn l "" +STARTLINE +INVISIBLE T GeoSelect.save_selection}
 addUserKnob {41 restore_selection l "restore selection" -STARTLINE T GeoSelect.restore_selection}
 addUserKnob {22 reset_selection l "reset selection" -STARTLINE T "nuke.thisGroup()\['geo'].fromScript('')\nnuke.thisGroup()\['savedata'].setValue('')"}
 addUserKnob {20 selection_data l "selection data" n 1}
 selection_data 0
 addUserKnob {43 savedata l "saved data" +DISABLED}
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 t_VERSION l Version}
 addUserKnob {26 l_VERSION l Version T 1.4}
 addUserKnob {26 l_DATE l "Date Modified" T 2021-03-23}
 addUserKnob {22 btn_CHANGELOG l Changelog T "log = \"1.4<br>-&nbsp;added&nbsp;'fail&nbsp;attempts'&nbsp;knob.&nbsp;(check&nbsp;tooltips)<br>-&nbsp;UV&nbsp;type&nbsp;set&nbsp;'single&nbsp;tile'&nbsp;by&nbsp;default<br><br>1.3<br>-&nbsp;compatible&nbsp;with&nbsp;python3<br>-&nbsp;fix&nbsp;'selected&nbsp;vertex&nbsp;info'&nbsp;button&nbsp;(it&nbsp;broke&nbsp;on&nbsp;last&nbsp;version)<br>-&nbsp;panel&nbsp;UI&nbsp;update<br><br>1.2<br>-&nbsp;Since&nbsp;generated&nbsp;group&nbsp;changed&nbsp;to&nbsp;'mSnap',&nbsp;<br>&nbsp;&nbsp;it&nbsp;breaks&nbsp;the&nbsp;unique&nbsp;name&nbsp;check,&nbsp;fixed&nbsp;on&nbsp;1.2&nbsp;.<br>-&nbsp;Added&nbsp;density&nbsp;map&nbsp;feature&nbsp;(alpha).<br>-&nbsp;Added&nbsp;RGB&nbsp;as&nbsp;texture&nbsp;color&nbsp;feature.<br>-&nbsp;Correct&nbsp;title&nbsp;name&nbsp;on&nbsp;tool's&nbsp;panel&nbsp;('texture&nbsp;setup'&nbsp;to&nbsp;input&nbsp;'setup').<br>-&nbsp;Minor&nbsp;fix&nbsp;normal&nbsp;to&nbsp;rotate&nbsp;algorithm&nbsp;(x&nbsp;rotation&nbsp;when&nbsp;-y&-z).<br>-&nbsp;Removed&nbsp;random&nbsp;selection&nbsp;checkbox.<br>&nbsp;&nbsp;&nbsp;*If&nbsp;don't&nbsp;need&nbsp;random&nbsp;selection,&nbsp;just&nbsp;keep&nbsp;random&nbsp;percentage=100.<br>-&nbsp;Adjust&nbsp;some&nbsp;backend&nbsp;code.<br>-&nbsp;'mScap'&nbsp;group&nbsp;added&nbsp;group&nbsp;info&nbsp;tab.<br>-&nbsp;Input&nbsp;of&nbsp;'mScatterGeo'&nbsp;changed&nbsp;name&nbsp;from&nbsp;'Geo'&nbsp;to&nbsp;'sampleGeo'.<br>-&nbsp;Fix&nbsp;rotation&nbsp;X&nbsp;under&nbsp;snap&nbsp;with&nbsp;normal&nbsp;rotation.<br>&nbsp;&nbsp;So&nbsp;it&nbsp;match&nbsp;to&nbsp;input&nbsp;geo&nbsp;origin.<br>-&nbsp;Fix&nbsp;ReadGeo's&nbsp;vertex&nbsp;normal&nbsp;rotation.<br>-&nbsp;Added&nbsp;delete&nbsp;instance&nbsp;on&nbsp;'mSnap'&nbsp;group.<br>-&nbsp;Added&nbsp;'select&nbsp;all'&nbsp;button&nbsp;on&nbsp;'mSnap'&nbsp;group.<br><br>1.1<br>-&nbsp;'MassiveSnapGeo'&nbsp;generated&nbsp;group&nbsp;renamed&nbsp;to&nbsp;'mSnap'<br>-&nbsp;fix&nbsp;slider&nbsp;UI&nbsp;after&nbsp;re-open&nbsp;nuke&nbsp;script&nbsp;on&nbsp;'mSnap'<br>-&nbsp;added&nbsp;display&nbsp;snap&nbsp;axis<br>-&nbsp;added&nbsp;extract&nbsp;axis<br><br>1.0<br>-&nbsp;re-work&nbsp;the&nbsp;unrelease&nbsp;version&nbsp;in&nbsp;2018\"\nnuke.message( log )" +STARTLINE}
 addUserKnob {26 l_DEV l "Developed by" T "<a href='https://youtube.com/c/MJTLab'><font color='orange'>Mark Joey Tang</font></a>"}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0xff
  label "dont touch"
  note_font_size 42
  xpos -510
  ypos -41
  bdwidth 232
  bdheight 407
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x848484ff
  label bin
  note_font_size 42
  xpos -241
  ypos -42
  bdwidth 307
  bdheight 637
 }
 Input {
  inputs 0
  name sampleGeo
  xpos 138
  ypos -38
 }
 Dot {
  name Dot1
  xpos 172
  ypos 64
 }
set N1e37b800 [stack 0]
 Normals {
  display off
  selectable false
  action build
  threshold 0
  name Normals
  xpos 292
  ypos 61
 }
 Dot {
  name Dot2
  xpos 326
  ypos 141
 }
set N1e37b000 [stack 0]
 PythonGeo {
  name PythonGeo
  xpos 292
  ypos 215
 }
 CurveTool {
  inputs 0
  operation "Auto Crop"
  channels alpha
  ROI {0 0 32 32}
  name CurveTool
  xpos -130
  ypos 128
 }
 NoOp {
  inputs 0
  name menu01
  knobChanged "\nif nuke.thisGroup()\['var_type'].value().lower() == 'framehold' :\n    nuke.thisGroup()\['frame_start'].setVisible(True)\n    nuke.thisGroup()\['frame_end'].setVisible(True)\n    nuke.thisGroup()\['offset_start'].setVisible(False)\n    nuke.thisGroup()\['offset_end'].setVisible(False)\nelif nuke.thisGroup()\['var_type'].value().lower() == 'timeoffset' :\n    nuke.thisGroup()\['frame_start'].setVisible(False)\n    nuke.thisGroup()\['frame_end'].setVisible(False)\n    nuke.thisGroup()\['offset_start'].setVisible(True)\n    nuke.thisGroup()\['offset_end'].setVisible(True)\nelse :\n    nuke.thisGroup()\['frame_start'].setVisible(False)\n    nuke.thisGroup()\['frame_end'].setVisible(False)\n    nuke.thisGroup()\['offset_start'].setVisible(False)\n    nuke.thisGroup()\['offset_end'].setVisible(False)\n"
  xpos -444
  ypos 64
  addUserKnob {20 User}
  addUserKnob {4 var_type l "variation type" M {Framehold TimeOffset}}
 }
push $N1e37b000
 Dot {
  name Dot3
  xpos 491
  ypos 141
 }
 Reformat {
  inputs 0
  type "to box"
  box_width {{"\[value parent.sample_res]"}}
  box_height {{"\[value parent.sample_res]"}}
  box_fixed true
  name Reformat1
  xpos 567
  ypos 322
 }
add_layer {pos pos.red pos.green pos.blue}
add_layer {nor nor.red nor.green nor.blue}
 ScanlineRender {
  inputs 2
  conservative_shader_sampling false
  projection_mode uv
  overscan {{"\[value parent.sample_res] * 9"}}
  motion_vectors_type off
  MB_channel none
  output_shader_vectors true
  P_channel pos
  N_channel nor
  name uvRender
  xpos 457
  ypos 322
 }
 Remove {
  operation keep
  channels rgba
  channels2 pos
  channels3 nor
  name Remove
  xpos 457
  ypos 402
 }
 Unpremult {
  name Unpremult1
  xpos 457
  ypos 482
  disable {{"parent.rgb_color == 1 ? 1 : 0"}}
 }
 Crop {
  box {0 0 {"\[value parent.sample_res] * 10"} {"\[value parent.sample_res] * 10"}}
  name UV1010
  xpos 457
  ypos 562
 }
 Clamp {
  channels rgba
  name Clamp1
  xpos 457
  ypos 642
 }
 Dot {
  name uv_dot
  tile_color 0xff0000ff
  xpos 491
  ypos 722
 }
 NoOp {
  inputs 0
  name store
  xpos -130
  ypos 52
  addUserKnob {20 User}
  addUserKnob {22 fn01 T "import math\nimport random\nimport time\n\n##### mode 0 = lookAt camera || 1 = vertices/faces normal || 2 = density map\n\ndef failCHK( _thisG , _failClass ) :\n\tcurNode = thisGRP\n\tfail = 0\n\twhile curNode :\n\t\tif curNode.Class() in _failClass :\n\t\t\tfail = 1\n\t\tcurNode = curNode.input(0)\n\treturn fail\n\n##########\n\ndef grouper( _n , _iterable ) :\n\timport itertools\n\targs = \[iter(_iterable)] * _n\n\ttry :\n\t\treturn itertools.zip_longest( *args )\n\texcept AttributeError:\n\t\treturn itertools.izip_longest( *args )\n\n##########\n\ndef geoData( _pyNode , _objnum ) :\n\tptsID = \[]\n\tfor i in _pyNode\['geo'].getGeometry()\[_objnum].primitives() :\n\t\tfor j in i :\n\t\t\tif ptsID.count( j ) == 0 :\n\t\t\t\tptsID.append( j )\n\n\tptsID.sort()\n\n\tvtxPos = list( grouper( 3 , list( _pyNode\['geo'].getGeometry()\[_objnum].points() ) ) )\n\tvtxNor = list( grouper( 3 , list( _pyNode\['geo'].getGeometry()\[_objnum].normals() ) ) )\n\n\tgeoFullset = \{\}\n\tfor i in ptsID :\n\t\tgeoFullset\[ str(_objnum) + '_' + str(i) ] = \[ vtxPos\[i] , vtxNor\[i] ]\n\t\n\treturn geoFullset\n\n##########\n\ndef findAvailableName( _name ) :\n\tfindName = 0\n\tdetectName = \[]\n\n\tfor node in nuke.allNodes():\n\t\tif node.name().split('_')\[0] == _name :\n\t\t\tdetectName.append(int(node.name().split('_')\[1]))\n\tdetectName.sort()\n\twhile detectName.count(findName) != 0 :\n\t\tfindName += 1\n\n\treturn findName\n\n##########\n\ndef makePackage( _name , _thisG ) :\n\tavailableName = findAvailableName( _name )\n\txspace = int( nuke.toNode('preferences')\['GridWidth'].getValue() )\n\n\tif _thisG\['var_type'].value().lower() == 'framehold' :\n\t\ttexRNG = \[ _thisG\['frame_start'].getValue() , _thisG\['frame_end'].getValue() ]\n\telif _thisG\['var_type'].value().lower() == 'timeoffset' :\n\t\ttexRNG = \[ _thisG\['offset_start'].getValue() , _thisG\['offset_end'].getValue() ]\n\n\t##### make group\n\tnewName = _name + '_' + str(availableName)\n\trandom.seed( int(time.time()) )\n\tsnapGRP = nuke.nodes.Group(\n\t\tname = newName , \n\t\ttile_color = int(thisGRP\['tile_color'].getValue()) , \n\t\txpos = thisGRP.xpos()+(xspace+random.randint(0,xspace)) , \n\t\typos = thisGRP.ypos()\n\t\t)\n\n\tsnapGRP.addKnob( nuke.Tab_Knob( 'tab_general', 'General' ) )\n\n\tsnapGRP.addKnob( nuke.Link_Knob( 'display_geo', 'display' ) )\n\tsnapGRP\['display_geo'].setLink('MassiveScene.display')\n\tsnapGRP.addKnob( nuke.Link_Knob( 'render_geo', 'render' ) )\n\tsnapGRP\['render_geo'].setLink('MassiveScene.render_mode')\n\n\tsnapGRP.addKnob( nuke.Text_Knob( 'title_random_tex', '<b>RANDOM INPUT</b>', '<i>( \{0\} )</i>'.format( _thisG\['var_type'].value() )  ) )\n\tsnapGRP.addKnob( nuke.Int_Knob( 'range_start', 'range' ) )\n\tsnapGRP\['range_start'].setValue( int( texRNG\[0] ) )\n\tsnapGRP.addKnob( nuke.Int_Knob( 'range_end', '' ) )\n\tsnapGRP\['range_end'].setValue( int( texRNG\[1] ) )\n\tsnapGRP\['range_end'].clearFlag( nuke.STARTLINE )\n\tsnapGRP.addKnob( nuke.Int_Knob( 'tex_seed', 'seed' ) )\n\n\tsnapGRP.addKnob( nuke.Text_Knob( 'title_random_trans', '<b>RANDOM FORMATION</b>' ) )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'rotateX_range', 'rotate X range' ) )\n\tsnapGRP\['rotateX_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'rotateX_seed', 'seed' ) )\n\tsnapGRP\['rotateX_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'rotateY_range', 'rotate Y range' ) )\n\tsnapGRP\['rotateY_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'rotateY_seed', 'seed' ) )\n\tsnapGRP\['rotateY_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'rotateZ_range', 'rotate Z range' ) )\n\tsnapGRP\['rotateZ_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'rotateZ_seed', 'seed' ) )\n\tsnapGRP\['rotateZ_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'scaleX_range', 'scale X range' ) )\n\tsnapGRP\['scaleX_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'scaleX_seed', 'seed' ) )\n\tsnapGRP\['scaleX_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'scaleY_range', 'scale Y range' ) )\n\tsnapGRP\['scaleY_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'scaleY_seed', 'seed' ) )\n\tsnapGRP\['scaleY_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'scaleZ_range', 'scale Z range' ) )\n\tsnapGRP\['scaleZ_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'scaleZ_seed', 'seed' ) )\n\tsnapGRP\['scaleZ_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Array_Knob( 'uniform_scale_range', 'uniform scale range' ) )\n\tsnapGRP\['uniform_scale_range'].setFlag(0x00000002)\n\tsnapGRP.addKnob( nuke.Array_Knob( 'uniform_scale_seed', 'seed' ) )\n\tsnapGRP\['uniform_scale_seed'].clearFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Tab_Knob( 'tab_misc', 'Misc' ) )\n\n\tsnapGRP.addKnob( nuke.Text_Knob( 'title_axis', '<b>SNAP AXIS</b>' ) )\n\tsnapGRP.addKnob( nuke.Boolean_Knob( 'display_axis', 'display snap axis' ) )\n\tsnapGRP\['display_axis'].setFlag( nuke.STARTLINE )\n\tsnapGRP.addKnob( nuke.Array_Knob( 'display_size', 'display size' ) )\n\tsnapGRP\['display_size'].setFlag(0x00000002)\n\tsnapGRP\['display_size'].setFlag( nuke.STARTLINE )\n\tsnapGRP\['display_size'].setValue( 1 )\n\tsnapGRP.addKnob( nuke.Link_Knob( 'display_color', 'color' ) )\n\tsnapGRP\['display_color'].setLink('menu01.display_color')\n\tsnapGRP\['display_color'].clearFlag( nuke.STARTLINE )\n\tsnapGRP.addKnob( nuke.PyScript_Knob( 'invert_selection', 'invert selection', \"for node in nuke.allNodes(\\'Axis\\') :\\n\\tif node.name()\[:3] == \\'ax_\\' :\\n\\t\\tnode\[\\'selected\\'].setValue( not node\[\\'selected\\'].value() )\" ) )\n\tsnapGRP\['invert_selection'].setFlag( nuke.STARTLINE )\n\tsnapGRP.addKnob( nuke.PyScript_Knob( 'deselect_all', 'de-select all', 'for node in nuke.allNodes() :\\n\\tnode.setSelected( False )' ) )\n\n\tsnapGRP.addKnob( nuke.Text_Knob( 'title_tools', '<b>TOOLS</b>' ) )\n\tsnapGRP.addKnob( nuke.Boolean_Knob( 'exTranslate', 'translate' ) )\n\tsnapGRP\['exTranslate'].setValue(True)\n\tsnapGRP.addKnob( nuke.Boolean_Knob( 'exRotate', 'rotate' ) )\n\tsnapGRP\['exRotate'].setValue(True)\n\tsnapGRP.addKnob( nuke.Boolean_Knob( 'exScale', 'scale' ) )\n\tsnapGRP\['exScale'].setValue(True)\n\tsnapGRP\['exTranslate'].setFlag( nuke.STARTLINE )\n\n\tif _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue() :\n\t\tsnapGRP.addKnob( nuke.Boolean_Knob( 'exColor', 'color' ) )\n\t\tsnapGRP\['exColor'].setFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.PyScript_Knob( 'extract_ins', 'extract selected instance', goStore\['cpCode02'].value() ) )\n\tsnapGRP\['extract_ins'].setFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Text_Knob( 'spacer', '', '<br>' ) )\n\t\n\tsnapGRP.addKnob( nuke.PyScript_Knob( 'remove_ins', 'remove selected instance', goStore\['cpCode03'].value() ) )\n\tsnapGRP\['remove_ins'].setFlag( nuke.STARTLINE )\n\n\tsnapGRP.addKnob( nuke.Tab_Knob( 'tab_info', 'Info', ) )\n\tsnapGRP.addKnob( nuke.Text_Knob( 'info_snap', '<font color=cyan>snap type :</font>', _thisG\['snap_type'].value() ) )\n\tsnapGRP.addKnob( nuke.Text_Knob( 'info_rot', '<font color=cyan>rotation type :</font>', _thisG\['rotation_type'].value() ) )\n\tsnapGRP.addKnob( nuke.Text_Knob( 'info_var', '<font color=cyan>input type :</font>', _thisG\['var_type'].value() ) )\n\tif _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue() :\n\t\tsnapGRP.addKnob( nuke.Text_Knob( 'info_tex', '<font color=cyan>texture :</font>', 'sample RGB color' ) )\n\telse :\n\t\tsnapGRP.addKnob( nuke.Text_Knob( 'info_tex', '<font color=cyan>texture :</font>', 'instance geo texture' ) )\n\tsnapGRP.addKnob( nuke.Text_Knob( 'info_inst', '<font color=cyan>total instance :</font>', '' ) )\n\tif _thisG\['with_animation'].getValue() :\n\t\tsnapGRP.addKnob( nuke.Text_Knob( 'info_aniRange', '<font color=cyan>anim frame range :</font>', '' ) )\n\n\tsnapGRP\['onCreate'].setValue( \"thisGRP = nuke.thisGroup()\\nknobs = \[\\'rotateX_range\\',\\'rotateY_range\\',\\'rotateZ_range\\',\\'scaleX_range\\',\\'scaleY_range\\',\\'scaleZ_range\\',\\'uniform_scale_range\\',\\'display_size\\']\\nfor knob in knobs :\\n\\tthisGRP\[knob].setFlag(0x00000002)\" )\n\n\treturn snapGRP\n\n##########\n\ndef selGons( _ptsID , _mainGeo ) :\n\t##### get quads prim group\n\tprim = geoPrims( _mainGeo )\n\n\tselVtxIDOnly = \[ int( i\[2:] ) for i in _ptsID ]\n\n\tgonsID = \[]\n\tfor ptsGRP in prim :\n\t\ttemp = 0\n\t\tfor i in ptsGRP :\n\t\t\ttemp += selVtxIDOnly.count( i )\n\t\tif temp != 0 :\n\t\t\tgonsID.append( '0_' + '_'.join( \[ str(j) for j in ptsGRP ] ) )\n\n\treturn gonsID\n\n##########\n\ndef sfvConvert( _svlist ) :\n\tprimNameList = \[]\n\tfor grp in _svlist :\n\t\ttemp = \[]\n\t\tfor vtx in range( len( grp ) ) :\n\t\t\ttemp.append( str( grp\[vtx] ) )\n\t\tprimNameList.append( '0_' + '_'.join( temp ) )\n\n\treturn primNameList\n\n##########\n\ndef genFaceNor( _thisG , _mainstream , _mainGeo , _svlist , _selType , _fRNG=\[0,0] ) :\n\tpyg = nuke.toNode('PythonGeo')\n\n\t##### get selected prims\n\tif _selType =='face' :\n\t\tprimID = sfvConvert( _svlist )\n\telif _selType == 'vertex' :\n\t\tprimID = _svlist\n\telif _selType == 'vertexFaces' :\n\t\tprimID = selGons( _svlist, _mainGeo )\n\n\t##### find available name and create global group\n\twith getLevel() :\n\t\tsnapGRP = makePackage( 'mSnap', _thisG )\n\n\t##### prep\n\twith snapGRP :\n\t\tgrpBasic( primID, _thisG )\n\n\t\t##### snap faces\n\t\t_mainstream.reverse()\n\n\t\tif _thisG\['with_animation'].value() :\n\t\t\tnuke.toNode('store')\['aniRNG'].setValue( '-'.join(\[str(i) for i in _fRNG]) )\n\t\t\tnuke.thisGroup()\['info_aniRange'].setValue( '-'.join(\[str(i) for i in _fRNG]) )\n\n\t\t\tct_hack = nuke.nodes.CurveTool()\n\t\t\tprogBar = nuke.ProgressTask('Sampling vertices')\n\t\t\tjobCount = 0\n\t\t\tjobTotal = ( _fRNG\[1] + 1 )- _fRNG\[0]\n\t\t\tfor ctime in range( _fRNG\[0] , _fRNG\[1] + 1 , 1 ) :\n\t\t\t\tnuke.execute(ct_hack, ctime, ctime)\n\t\t\t\t### progress bar\n\t\t\t\tjobCount += 1\n\t\t\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\t\t\tif progBar.isCancelled() :\n\t\t\t\t\tbreak;\n\t\t\t\tprogBar.setProgress(progShow)\n\t\t\t\t#################\n\n\t\t\t\tgData = geoData( pyg , 0 ) ##### get geo data\n\t\t\t\tfor node in nuke.allNodes( 'Axis' ) :\n\t\t\t\t\tif node.name() != 'worldTransform' :\n\t\t\t\t\t\tkname = node.name().split('_')\[2:]\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ctime == _fRNG\[0] :\n\t\t\t\t\t\t\tnode\['translate'].setAnimated()\n\t\t\t\t\t\t\tnode\['orig_rot'].setAnimated()\n\n\t\t\t\t\t\tif _selType == 'face' or _selType == 'vertexFaces' :\n\t\t\t\t\t\t\tvec1 = nuke.math.Vector3( \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[0]) ]\[0]\[0] , \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[0]) ]\[0]\[1] , \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[0]) ]\[0]\[2] \n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tvec2 = nuke.math.Vector3( \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[1]) ]\[0]\[0] , \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[1]) ]\[0]\[1] , \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[1]) ]\[0]\[2] \n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tvec3 = nuke.math.Vector3( \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[2]) ]\[0]\[0] , \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[2]) ]\[0]\[1] , \n\t\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[2]) ]\[0]\[2] \n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\tnode\['translate'].setValueAt( nukescripts.snap3d.calcAveragePosition( convertIter( gData, kname ) )\[i], ctime, i )\n\t\t\t\t\t\t\t\tnode\['orig_rot'].setValueAt( math.degrees(nukescripts.snap3d.planeRotation( (vec1, vec2, vec3) , norm=None)\[i]), ctime, i )\n\n\t\t\t\t\t\t\tdel vec1, vec2, vec3\n\t\t\t\t\t\telif _selType == 'vertex' :\n\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\tnode\['translate'].setValueAt( gData\['0_' + kname\[0]]\[0]\[i], ctime, i )\n\t\t\t\t\t\t\t\tnode\['orig_rot'].setValueAt( norToRot3D( gData , '0_' + kname\[0] )\[i], ctime, i )\n\t\t\t\t\t\n\t\t\t\t\tif node.name() == 'worldTransform' :\n\t\t\t\t\t\twTrans = unify( _mainstream , ctime ) ##### get world transformation\n\t\t\t\t\t\tnode\['useMatrix'].setValue(True)\n\t\t\t\t\t\tnode\['matrix'].setAnimated()\n\t\t\t\t\t\tfor mtx in range(16) :\n\t\t\t\t\t\t\tnode\['matrix'].setValueAt( wTrans\[mtx] , ctime , mtx )\n\n\t\t\tnuke.delete( ct_hack )\n\t\t\tdel progBar, jobCount, jobTotal, progShow\n\n\t\telse :\n\t\t\tgData = geoData( pyg , 0 ) ##### get geo data\n\t\t\tfor node in nuke.allNodes( 'Axis' ) :\n\t\t\t\tif node.name() != 'worldTransform' :\n\t\t\t\t\tkname = node.name().split('_')\[2:]\n\n\t\t\t\t\tif _selType == 'face' or _selType == 'vertexFaces' :\n\t\t\t\t\t\tvec1 = nuke.math.Vector3( \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[0]) ]\[0]\[0] , \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[0]) ]\[0]\[1] , \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[0]) ]\[0]\[2] \n\t\t\t\t\t\t\t)\n\t\t\t\t\t\tvec2 = nuke.math.Vector3( \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[1]) ]\[0]\[0] , \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[1]) ]\[0]\[1] , \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[1]) ]\[0]\[2] \n\t\t\t\t\t\t\t)\n\t\t\t\t\t\tvec3 = nuke.math.Vector3( \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[2]) ]\[0]\[0] , \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[2]) ]\[0]\[1] , \n\t\t\t\t\t\t\tgData\[ '0_' + str(kname\[2]) ]\[0]\[2] \n\t\t\t\t\t\t\t)\n\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\tnode\['translate'].setValue( nukescripts.snap3d.calcAveragePosition( convertIter( gData, kname ) )\[i], i )\n\t\t\t\t\t\t\tnode\['orig_rot'].setValue( math.degrees(nukescripts.snap3d.planeRotation( (vec1, vec2, vec3), norm=None)\[i]), i )\n\t\t\t\t\telif _selType == 'vertex' :\n\t\t\t\t\t\tnode\['translate'].setValue( gData\['0_' + kname\[0]]\[0] )\n\t\t\t\t\t\tnode\['orig_rot'].setValue( norToRot3D( gData , '0_' + kname\[0] ) )\n\n\t\t\t\tif node.name() == 'worldTransform' :\n\t\t\t\t\twTrans = unify( _mainstream , nuke.frame() ) ##### get world transformation\n\t\t\t\t\tnode\['useMatrix'].setValue(True)\n\t\t\t\t\tfor mtx in range(16) :\n\t\t\t\t\t\tnode\['matrix'].setValue( wTrans\[mtx] , mtx )\n\n\tdel primID, gData, kname, snapGRP, wTrans, _thisG, _mainstream, _mainGeo, _svlist, _selType, _fRNG\n\n##########\n\ndef genSelVtx( _thisG , _mainstream , _svlist , _selType , _fRNG=\[0,0] ) :\n\tpyg = nuke.toNode('PythonGeo')\n\n\t##### find available name and create global group\n\twith getLevel() :\n\t\tsnapGRP = makePackage( 'mSnap', _thisG )\n\n\t##### prep\n\twith snapGRP :\n\t\tif _selType == 'face' :\n\t\t\tgrpBasic( sfvConvert( _svlist ), _thisG )\n\t\telif _selType == 'vertex' :\n\t\t\tgrpBasic( _svlist, _thisG )\n\n\t\t##### snap points\n\t\t_mainstream.reverse()\n\n\t\tif _thisG\['with_animation'].value() :\n\t\t\tnuke.toNode('store')\['aniRNG'].setValue( '-'.join(\[str(i) for i in _fRNG]) )\n\t\t\tnuke.thisGroup()\['info_aniRange'].setValue( '-'.join(\[str(i) for i in _fRNG]) )\n\n\t\t\tct_hack = nuke.nodes.CurveTool()\n\t\t\tprogBar = nuke.ProgressTask('Sampling vertices')\n\t\t\tjobCount = 0\n\t\t\tjobTotal = ( _fRNG\[1] + 1 )- _fRNG\[0]\n\n\t\t\tfor ctime in range( _fRNG\[0] , _fRNG\[1] + 1 ) :\n\t\t\t\tnuke.execute(ct_hack, ctime, ctime)\n\t\t\t\t### progress bar\n\t\t\t\tjobCount += 1\n\t\t\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\t\t\tif progBar.isCancelled() :\n\t\t\t\t\tbreak;\n\t\t\t\tprogBar.setProgress(progShow)\n\t\t\t\t#################\n\n\t\t\t\tgData = geoData( pyg , 0 ) ##### get geo data\n\t\t\t\tfor node in nuke.allNodes( 'Axis' ) :\n\t\t\t\t\tif node.name() != 'worldTransform' :\n\t\t\t\t\t\tkname = node.name().split('_')\[2:]\n\t\t\t\t\t\t\n\t\t\t\t\t\tif _selType == 'face' :\n\t\t\t\t\t\t\tif ctime == _fRNG\[0] :\n\t\t\t\t\t\t\t\tnode\['translate'].setAnimated()\n\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\tnode\['translate'].setValueAt(nukescripts.snap3d.calcAveragePosition( convertIter( gData, kname ) )\[i], ctime, i)\n\t\t\t\t\t\telif _selType == 'vertex' :\n\t\t\t\t\t\t\tif ctime == _fRNG\[0] :\n\t\t\t\t\t\t\t\tnode\['translate'].setAnimated()\n\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\tnode\['translate'].setValueAt( gData\['0_' + kname\[0]]\[0]\[i] , ctime , i )\n\t\t\t\t\t\n\t\t\t\t\tif node.name() == 'worldTransform' :\n\t\t\t\t\t\twTrans = unify( _mainstream , ctime ) ##### get world transformation\n\t\t\t\t\t\tnode\['useMatrix'].setValue(True)\n\t\t\t\t\t\tnode\['matrix'].setAnimated()\n\t\t\t\t\t\tfor mtx in range(16) :\n\t\t\t\t\t\t\tnode\['matrix'].setValueAt( wTrans\[mtx] , ctime , mtx )\n\n\t\t\tnuke.delete( ct_hack )\n\t\t\tdel progBar, jobCount, jobTotal, progShow\n\n\t\telse :\n\t\t\tgData = geoData( pyg , 0 ) ##### get geo data\n\t\t\tfor node in nuke.allNodes( 'Axis' ) :\n\t\t\t\tif node.name() != 'worldTransform' :\n\t\t\t\t\tkname = node.name().split('_')\[2:]\n\t\t\t\t\t\n\t\t\t\t\tif _selType == 'face' :\n\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\tnode\['translate'].setValue(nukescripts.snap3d.calcAveragePosition( convertIter( gData, kname ) )\[i], i)\n\t\t\t\t\telif _selType == 'vertex' :\n\t\t\t\t\t\tnode\['translate'].setValue( gData\['0_' + kname\[0]]\[0] )\n\t\t\t\t\n\t\t\t\tif node.name() == 'worldTransform' :\n\t\t\t\t\twTrans = unify( _mainstream , nuke.frame() ) ##### get world transformation\n\t\t\t\t\tnode\['useMatrix'].setValue(True)\n\t\t\t\t\tfor mtx in range(16) :\n\t\t\t\t\t\tnode\['matrix'].setValue( wTrans\[mtx] , mtx )\n\n\tdel gData, kname, snapGRP, wTrans, _thisG, _mainstream, _svlist, _selType, _fRNG\n\n##########\n\ndef convertIter( _gd , _prim ) :\n\tloopNum = len( _prim )\n\tfor i in range( loopNum ) :\n\t\ttPos = nuke.math.Vector4( \n\t\t\t_gd\[ '0_' + str(_prim\[i]) ]\[0]\[0] , \n\t\t\t_gd\[ '0_' + str(_prim\[i]) ]\[0]\[1] , \n\t\t\t_gd\[ '0_' + str(_prim\[i]) ]\[0]\[2] , \n\t\t\t1.0\n\t\t\t)\n\t\tyield nukescripts.snap3d.VertexInfo(0, 0, 1, nuke.math.Vector3(tPos.x, tPos.y, tPos.z))\n\n##########\n\ndef grpBasic( _data , _thisG ) :\n\tglColor = int('%02x%02x%02x%02x' % (1*255,0*255,0*255,1),16)\n\n\tgeoInput = nuke.nodes.Input( name = 'geo')\n\n\tif _thisG\['rotation_type'].getValue() == 0 :\n\t\tcamInput = nuke.nodes.Input( name = 'axis_cam')\n\n\tgeoDot = nuke.nodes.Dot()\n\tgeoDot.setInput(0, geoInput)\n\n\tsceneAll = nuke.nodes.Scene( name = 'MassiveScene' )\n\tnuke.nodes.Output( inputs=\[sceneAll] )\n\n\tmenu01 = nuke.nodes.NoOp( name = 'menu01' )\n\tmenu01.addKnob( nuke.ColorChip_Knob( 'display_color', 'color' ) )\n\tmenu01\['knobChanged'].setValue( goStore\['cpCode01'].value() )\n\tmenu01\['display_color'].setValue( glColor )\n\n\t##### copy function\n\tcopyStore = nuke.nodes.NoOp( name = 'store' )\n\tcopyStore.addKnob( nuke.PyScript_Knob( 'fn', 'fn', goStore\['fn02'].value() ) )\n\tcopyStore.addKnob( nuke.Multiline_Eval_String_Knob( 'filterNonReverse', 'filterNonReverse', goStore\['filterNonReverse'].value() ) )\n\tcopyStore\['filterNonReverse'].setEnabled( False )\n\tcopyStore.addKnob( nuke.Multiline_Eval_String_Knob( 'filter3DNodes', 'filter3DNodes', goStore\['filter3DNodes'].value() ) )\n\tcopyStore\['filter3DNodes'].setEnabled( False )\n\tif _thisG\['with_animation'].value() :\n\t\tcopyStore.addKnob( nuke.EvalString_Knob( 'aniRNG', 'aniRNG' , '1001-1100' ) )\n\n\t##### apply geo's transformation\n\tworldTrans = nuke.nodes.Axis(\n\t\tname = 'worldTransform' , \n\t\tdisplay = 'off' , \n\t\tselectable = 0\n\t\t)\n\n\t##### RGB color setup\n\tif _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue() :\n\t\tcolorRes = nuke.nodes.Reformat(\n\t\t\t\t\ttype = 1 ,\n\t\t\t\t\tbox_fixed = True ,\n\t\t\t\t\tbox_width = 32 , box_height = 32\n\t\t\t\t\t)\n\t\tcolorBasic = nuke.nodes.Expression(\n\t\t\t\t\tchannel0 = 'red' , channel1 = 'green' , channel2 = 'blue' , channel3 = 'alpha' , \n\t\t\t\t\texpr0 = '1' , expr1 = '1' , expr2 = '1' , expr3 = '1' , \n\t\t\t\t\tinputs = \[colorRes]\n\t\t\t\t\t)\n\n\t##### mass generate\n\tfor key in range (0, len(_data)) :\n\t\trandTexEX = 'trunc( ( random(tex_seed, \{0\}) * (range_end-range_start) ) + range_start )'.format( key ) \n\t\tif _thisG\['var_type'].getValue() == 0 :\n\t\t\trandomVar = nuke.nodes.FrameHold()\n\t\t\trandomVar\['first_frame'].setExpression( randTexEX )\n\t\telse :\n\t\t\trandomVar = nuke.nodes.TimeOffset()\n\t\t\trandomVar\['time_offset'].setExpression( randTexEX )\n\t\trandomVar.setInput(0, geoDot)\n\n\t\tscatterAX = nuke.nodes.Axis(\n\t\t\tname = 'ax_' + _data\[key] , \n\t\t\tgl_color = glColor , \n\t\t\tinputs = \[worldTrans]\n\t\t\t)\n\n\t\t##### axis setting\n\t\tscatterAX\['display'].setExpression( 'parent.display_axis' )\n\t\tscatterAX\['scaling'].setExpression( 'random( \{2\}, \{0\} ) * parent.\{1\} + (1-parent.\{1\})'.format( key , 'scaleX_range' , 'scaleX_seed' ) , 0 )\n\t\tscatterAX\['scaling'].setExpression( 'random( \{2\}, \{0\} ) * parent.\{1\} + (1-parent.\{1\})'.format( key , 'scaleY_range' , 'scaleY_seed' ) , 1 )\n\t\tscatterAX\['scaling'].setExpression( 'random( \{2\}, \{0\} ) * parent.\{1\} + (1-parent.\{1\})'.format( key , 'scaleZ_range' , 'scaleZ_seed' ) , 2 )\n\t\tscatterAX\['uniform_scale'].setExpression( '( random(\{2\},\{0\}) * parent.\{1\} + (1-parent.\{1\}) ) * parent.\{3\}'.format( key , 'uniform_scale_range' , 'uniform_scale_seed', 'display_size' ) )\n\n\t\tscatterAX.addKnob( nuke.Array_Knob( 'axid' , 'axid' ) )\n\t\tscatterAX\['axid'].setValue( key )\n\t\tscatterAX.addKnob( nuke.XYZ_Knob( 'orig_rot' , 'orig_rot' ) )\n\t\tscatterAX\['rotate'].setExpression( 'random( \{2\}, \{0\} ) * 360 * \{1\} + \{3\}'.format( 'axid' , 'rotateX_range' , 'rotateX_seed' , 'orig_rot' ) , 0 )\n\t\tscatterAX\['rotate'].setExpression( 'random( \{2\}, \{0\} ) * 360 * \{1\} + \{3\}'.format( 'axid' , 'rotateY_range' , 'rotateY_seed' , 'orig_rot' ) , 1 )\n\t\tscatterAX\['rotate'].setExpression( 'random( \{2\}, \{0\} ) * 360 * \{1\} + \{3\}'.format( 'axid' , 'rotateZ_range' , 'rotateZ_seed' , 'orig_rot' ) , 2 )\n\n\t\tgenTransGeo = nuke.nodes.TransformGeo()\n\t\tgenTransGeo\['uniform_scale'].setExpression( '1 / \{0\}'.format( 'display_size' ) )\n\t\tgenTransGeo.setInput(0, randomVar)\n\t\tgenTransGeo.setInput(1, scatterAX)\n\n\t\tif _thisG\['rotation_type'].getValue() == 0 :\n\t\t\tgenTransGeo.setInput(2, camInput)\n\n\t\t##### RGB color setup\n\t\tif _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue() :\n\t\t\tappColor = nuke.nodes.Multiply(\n\t\t\t\t\t\t\tname = 'cc_' + _data\[key] , \n\t\t\t\t\t\t\tinputs = \[colorBasic]\n\t\t\t\t\t\t\t)\n\t\t\tappColor\['value'].setSingleValue(False)\n\t\t\tappMat = nuke.nodes.ApplyMaterial(\n\t\t\t\t\t\tinputs = \[genTransGeo , appColor]\n\t\t\t\t\t\t)\n\t\t\tsceneAll.setInput( key, appMat )\n\t\telse :\n\t\t\tsceneAll.setInput( key, genTransGeo )\n\n\tnuke.thisGroup()\['info_inst'].setValue( str(len(_data)) )\n\n##########\n\ndef selID() :\n\tchkid = \[]\n\tselobj = \[]\n\tselidx = \[]\n\tselpos = \[]\n\trm = \[]\n\tcount = 0\n\n\tfor vtx in nukescripts.snap3d.selectedVertexInfos() :\n\t\ttemp = str( vtx.objnum ) + '_' + str( vtx.index )\n\t\tif not chkid.count( temp ) :\n\t\t\tchkid.append( temp )\n\n\t\t\tif selidx.count( vtx.index ) :\n\t\t\t\tplace = selidx.index( vtx.index )\n\t\t\t\tif selpos\[place] == vtx.position :\n\t\t\t\t\tif selobj\[place] < vtx.objnum :\n\t\t\t\t\t\trm.append( place )\n\t\t\t\t\telse :\n\t\t\t\t\t\trm.append( count )\n\n\t\t\tselobj.append( vtx.objnum )\n\t\t\tselidx.append( vtx.index )\n\t\t\tselpos.append( vtx.position )\n\t\t\tcount += 1\n\n\tselPts = \[]\n\n\tfor i in range( len(selpos) ) :\n\t\tif i not in rm :\n\t\t\tselPts.append( str(selobj\[i]) + '_' + str(selidx\[i]) )\n\n\tdel chkid, selobj, selidx, selpos, rm, count\n\n\treturn selPts\n\n##########\n\ndef randSelID( _slist , _thisG ) :\n\trandMax = round( max( 0 , min( 1 , _thisG\['random_percentage'].getValue()/100 ) ) * len( _slist ) )\n\trandID = \[]\n\trandom.seed( int( _thisG\['random_seed'].getValue() ) )\n\twhile len( randID ) < randMax :\n\t\tchoosenOne = _slist\[ random.randint( 0, len( _slist )-1 ) ]\n\t\tif not choosenOne in randID :\n\t\t\trandID.append( choosenOne )\n\n\treturn randID\n\n##########\n\ndef primaryGeo( _mainstream , _filterPrimitives ) :\n\tfor sub in _mainstream :\n\t\tfor node in sub :\n\t\t\tif node.Class() in _filterPrimitives :\n\t\t\t\treturn node\n\n##########\n\ndef geoPrims( _mainGeo ) :\n\tgonType = len( nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives() )\n\tif gonType > 1 :\n\t\t##### tris\n\t\tgPrims = list( nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives() )\n\telse :\n\t\tif _mainGeo.Class() == 'ReadGeo' or _mainGeo.Class() == 'ReadGeo2' :\n\t\t\t##### custom geo\n\t\t\tgPrims = \[]\n\t\t\tprims = nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives()\n\t\t\tfor prim in grouper( 4, prims\[0] ) :\n\t\t\t\tgPrims.append( prim )\n\t\telse :\n\t\t\t##### quads\n\t\t\tgPrims = \[]\n\t\t\tfor prim in _mainGeo\['geo_select'].getGeometry().__getitem__(0).primitives() :\n\t\t\t\tfor face in range(0, prim.faces()):\n\t\t\t\t\tgPrims.append( prim.faceVertices( face ) )\n\n\treturn gPrims\n\n##########\n\ndef norToRot3D( _gData , _vid ) :\n\t##### rotate x\n\trx = -math.asin( _gData\[ _vid ]\[1]\[1] )\n\n\t##### rotate y\n\ttry :\n\t\tif _gData\[ _vid ]\[1]\[2] < 0 and _gData\[ _vid ]\[1]\[0] < 0 :\n\t\t\try = -( math.pi + math.asin( _gData\[ _vid ]\[1]\[0] / math.cos( -math.asin( _gData\[ _vid ]\[1]\[1] ) ) ) )\n\t\telif _gData\[ _vid ]\[1]\[2] < 0 and _gData\[ _vid ]\[1]\[0] > 0 :\n\t\t\try = math.pi - math.asin( _gData\[ _vid ]\[1]\[0] / math.cos( -math.asin( _gData\[ _vid ]\[1]\[1] ) ) )\n\t\telse :\n\t\t\try = math.asin( _gData\[ _vid ]\[1]\[0] / math.cos( -math.asin( _gData\[ _vid ]\[1]\[1] ) ) )\n\texcept ValueError :\n\t\tif _gData\[ _vid ]\[1]\[0] > 0 :\n\t\t\try = 90\n\t\telse :\n\t\t\try = -90\n\n\tdel _gData , _vid\n\n\trot3 = \[ math.degrees( rx )%360+90 , math.degrees( ry )%360 , 0]\n\treturn rot3\n\n##########\n\ndef norToRotMap( _nor ) :\n\t##### rotate x\n\trx = -math.asin( _nor\[1] )\n\n\t##### rotate y\n\ttry :\n\t\tif _nor\[2] < 0 and _nor\[0] < 0 :\n\t\t\try = -( math.pi + math.asin( _nor\[0] / math.cos( -math.asin( _nor\[1] ) ) ) )\n\t\telif _nor\[2] < 0 and _nor\[0] > 0 :\n\t\t\try = math.pi - math.asin( _nor\[0] / math.cos( -math.asin( _nor\[1] ) ) )\n\t\telse :\n\t\t\try = math.asin( _nor\[0] / math.cos( -math.asin( _nor\[1] ) ) )\n\texcept ValueError :\n\t\tif _nor\[0] > 0 :\n\t\t\try = 90\n\t\telse :\n\t\t\try = -90\n\n\tdel _nor\n\n\trot3 = \[ math.degrees( rx )%360+90 , math.degrees( ry )%360 , 0]\n\treturn rot3\n\n##########\n\ndef scanTile( _thisG , _startNode , _ctNode, _res ) :\n\t##### setup curveTool node\n\tscanCropSize = 32\n\t_ctNode\['operation'].setValue( 'Auto Crop')\n\t_ctNode\['channels'].setValue( 'alpha')\n\t_ctNode\['ROI'].setValue( \[ 0 , 0 , scanCropSize , scanCropSize ] )\n\n\tsNodes = \[]\n\tuvShift = nuke.nodes.Transform( inputs = \[_startNode] )\n\tcrop32 = nuke.nodes.Crop( inputs = \[uvShift] )\n\tcrop32\['box'].setValue( \[ 0 , 0 , _res , _res ] )\n\tscan32 = nuke.nodes.Reformat(\n\t\t\t\t\t\ttype = 1 , box_fixed = True , box_width = scanCropSize , box_height = scanCropSize ,\n\t\t\t\t\t\tinputs = \[crop32]\n\t\t\t\t\t\t)\n\n\tif _thisG\['uv_type'].getValue() == 0 :\n\t\t_ctNode.setInput( 0, scan32 )\n\t\tnuke.execute( _ctNode, nuke.frame(), nuke.frame() )\n\t\tcropResult = _ctNode\['autocropdata'].getValue()\n\t\tif ( cropResult\[2] - cropResult\[0] ) > 0 or ( cropResult\[3] - cropResult\[1] ) > 0 :\n\t\t\tuvCrop = nuke.nodes.Crop( \n\t\t\t\t\t\tname = 'crop_00' ,\n\t\t\t\t\t\treformat = True , \n\t\t\t\t\t\tinputs = \[uvShift] \n\t\t\t\t\t\t)\n\t\t\tfor i in range(4) :\n\t\t\t\tuvCrop\['box'].setValue( cropResult\[i] * _res/scanCropSize , i )\n\t\t\tsNodes.append( uvCrop )\n\t\telse :\n\t\t\tnuke.delete( uvShift )\n\telse :\n\t\tfor y in range(10) :\n\t\t\tfor x in range(10) :\n\t\t\t\tuvShift\['translate'].setValue( -(_res*x) , 0 )\n\t\t\t\tuvShift\['translate'].setValue( -(_res*y) , 1 )\n\t\t\t\t#uvShift\['label'].setValue( 'tile : \{0\} | \{1\}' .format( str(x), str(y) ) )\n\t\t\t\t\n\t\t\t\t_ctNode.setInput( 0, scan32 )\n\t\t\t\tnuke.execute( _ctNode, nuke.frame(), nuke.frame() )\n\t\t\t\tcropResult = _ctNode\['autocropdata'].getValue()\n\n\t\t\t\tif ( cropResult\[2] - cropResult\[0] ) > 0 or ( cropResult\[3] - cropResult\[1] ) > 0 :\n\t\t\t\t\tnuke.delete( crop32 )\n\t\t\t\t\tnuke.delete( scan32 )\n\t\t\t\t\tuvCrop = nuke.nodes.Crop( \n\t\t\t\t\t\t\t\tname = 'crop_\{0\}\{1\}'.format( str(y) , str(x) ) ,\n\t\t\t\t\t\t\t\treformat = True , \n\t\t\t\t\t\t\t\tinputs = \[uvShift] \n\t\t\t\t\t\t\t\t)\n\t\t\t\t\tfor i in range(4) :\n\t\t\t\t\t\tuvCrop\['box'].setValue( cropResult\[i] * _res/scanCropSize , i )\n\t\t\t\t\tsNodes.append( uvCrop )\n\t\t\t\t\tuvShift = nuke.nodes.Transform( inputs = \[_startNode] )\n\t\t\t\t\tcrop32 = nuke.nodes.Crop( inputs = \[uvShift] )\n\t\t\t\t\tcrop32\['box'].setValue( \[0,0,512,512] )\n\t\t\t\t\tscan32 = nuke.nodes.Reformat(\n\t\t\t\t\t\t\ttype = 1 , box_fixed = True , box_width = scanCropSize , box_height = scanCropSize ,\n\t\t\t\t\t\t\tinputs = \[crop32]\n\t\t\t\t\t\t\t)\n\t\t\t\telif x == 9 and y == 9 :\n\t\t\t\t\tnuke.delete( uvShift )\n\n\tnuke.delete( crop32 )\n\tnuke.delete( scan32 )\n\t_ctNode\['autocropdata'].clearAnimated()\n\t_ctNode.setInput( 0, None )\n\n\treturn sNodes\n\n##########\n\ndef rmNodes( _uvST ) :\n\tfollowNodes = _uvST.dependent()\n\tfor node in followNodes :\n\t\tcheck = 0\n\t\tcNodes = \[node]\n\t\twhile check < 1 :\n\t\t\tif len(cNodes\[-1:]\[0].dependent()) != 0 :\n\t\t\t\tcNodes.append( cNodes\[-1:]\[0].dependent()\[0] )\n\t\t\telse :\n\t\t\t\tcheck = 1\n\t\tfor rm in cNodes :\n\t\t\tnuke.delete( rm )\n\n##########\n\ndef genDMap( _thisG , _svlist , _sNodes , _fRNG=\[0,0] ) :\n\t##### find available name and create global group\n\twith getLevel() :\n\t\tsnapGRP = makePackage( 'mSnap', _thisG )\n\n\t##### prep\n\twith snapGRP :\n\t\tgrpBasic( _svlist, _thisG )\n\n\t\t##### RGB color\n\t\tif _thisG\['rgb_color'].value() :\n\t\t\tfor node in nuke.allNodes( 'Multiply' ) :\n\t\t\t\tkname = node.name().split('_')\[1:]\n\n\t\t\t\tfor cropNode in _sNodes :\n\t\t\t\t\tif cropNode.name() == 'crop_\{0\}'.format(kname\[0]) :\n\t\t\t\t\t\trgb = \[ cropNode.sample('red', int(kname\[1]), int(kname\[2])) , cropNode.sample('green', int(kname\[1]), int(kname\[2])) , cropNode.sample('blue', int(kname\[1]), int(kname\[2])) ]\n\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\tnuke.toNode( 'cc_\{0\}'.format( '_'.join(kname) ) )\['value'].setValue( rgb\[i], i )\n\n\t\t##### snap\n\t\tif _thisG\['with_animation'].value() :\n\t\t\tnuke.toNode('store')\['aniRNG'].setValue( '-'.join(\[str(i) for i in _fRNG]) )\n\t\t\tnuke.thisGroup()\['info_aniRange'].setValue( '-'.join(\[str(i) for i in _fRNG]) )\n\n\t\t\tct_hack = nuke.nodes.CurveTool()\n\t\t\tprogBar = nuke.ProgressTask('Sampling Position')\n\t\t\tjobCount = 0\n\t\t\tjobTotal = ( _fRNG\[1] + 1 )- _fRNG\[0]\n\t\t\tfor ctime in range( _fRNG\[0] , _fRNG\[1] + 1 , 1 ) :\n\t\t\t\tnuke.execute(ct_hack, ctime, ctime)\n\t\t\t\t### progress bar\n\t\t\t\tjobCount += 1\n\t\t\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\t\t\tif progBar.isCancelled() :\n\t\t\t\t\tbreak;\n\t\t\t\tprogBar.setProgress(progShow)\n\t\t\t\t#################\n\t\t\t\tfor node in nuke.allNodes( 'Axis' ) :\n\t\t\t\t\tif node.name() != 'worldTransform' :\n\t\t\t\t\t\tkname = node.name().split('_')\[1:]\n\n\t\t\t\t\t\tif ctime == _fRNG\[0] :\n\t\t\t\t\t\t\tnode\['translate'].setAnimated()\n\t\t\t\t\t\t\tif _thisG\['rotation_type'].getValue() :\n\t\t\t\t\t\t\t\tnode\['orig_rot'].setAnimated()\n\n\t\t\t\t\t\tfor cropNode in _sNodes :\n\t\t\t\t\t\t\tif cropNode.name() == 'crop_\{0\}'.format(kname\[0]) :\n\t\t\t\t\t\t\t\tpos = \[ cropNode.sample('pos.red', int(kname\[1]), int(kname\[2])) , cropNode.sample('pos.green', int(kname\[1]), int(kname\[2])) , cropNode.sample('pos.blue', int(kname\[1]), int(kname\[2])) ]\n\t\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\t\tnode\['translate'].setValueAt( pos\[i], ctime, i )\n\n\t\t\t\t\t\t\t\t##### snap rotation\n\t\t\t\t\t\t\t\tif _thisG\['rotation_type'].getValue() :\n\t\t\t\t\t\t\t\t\tnor = \[ cropNode.sample('nor.red', int(kname\[1]), int(kname\[2])) , cropNode.sample('nor.green', int(kname\[1]), int(kname\[2])) , cropNode.sample('nor.blue', int(kname\[1]), int(kname\[2])) ]\n\t\t\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\t\t\tnode\['orig_rot'].setValueAt( norToRotMap( nor )\[i], ctime, i )\n\t\t\t\n\t\t\tnuke.delete( ct_hack )\n\t\t\tdel progBar, jobCount, jobTotal, progShow\n\n\t\telse :\n\t\t\tfor node in nuke.allNodes( 'Axis' ) :\n\t\t\t\tif node.name() != 'worldTransform' :\n\t\t\t\t\tkname = node.name().split('_')\[1:]\n\t\t\t\t\t\n\t\t\t\t\tfor cropNode in _sNodes :\n\t\t\t\t\t\tif cropNode.name() == 'crop_\{0\}'.format(kname\[0]) :\n\t\t\t\t\t\t\tpos = \[ cropNode.sample('pos.red', int(kname\[1]), int(kname\[2])) , cropNode.sample('pos.green', int(kname\[1]), int(kname\[2])) , cropNode.sample('pos.blue', int(kname\[1]), int(kname\[2])) ]\n\t\t\t\t\t\t\tnode\['translate'].setValue( pos )\n\n\t\t\t\t\t\t\t##### snap rotation\n\t\t\t\t\t\t\tif _thisG\['rotation_type'].getValue() :\n\t\t\t\t\t\t\t\tnor = \[ cropNode.sample('nor.red', int(kname\[1]), int(kname\[2])) , cropNode.sample('nor.green', int(kname\[1]), int(kname\[2])) , cropNode.sample('nor.blue', int(kname\[1]), int(kname\[2])) ]\n\t\t\t\t\t\t\t\tfor i in range(3) :\n\t\t\t\t\t\t\t\t\tnode\['orig_rot'].setValue( norToRotMap( nor )\[i], i )\n\n##########\n\ndef samID( _thisG , _tileData ) :\n\t#print (_tileData)\n\tpos2D = \[]\n\trandom.seed( int( _thisG\['dmap_seed'].getValue() ) )\n\tfor key, value in _tileData.items() :\n\t\tcount = 0\n\t\tsubCount = 0\n\t\tp2Data = \[]\n\t\twhile count < value\[1] :\n\t\t\tsamXY = \[ random.randint( 0 , value\[0].width() ) , random.randint( 0 , value\[0].height() ) ]\n\t\t\talpha = value\[0].sample('alpha', samXY\[0], samXY\[1])\n\t\t\tpos = \[ value\[0].sample('pos.red', samXY\[0], samXY\[1]) , value\[0].sample('pos.green', samXY\[0], samXY\[1]) , value\[0].sample('pos.blue', samXY\[0], samXY\[1]) ]\n\t\t\tif alpha > 0 and samXY not in p2Data and pos != \[0,0,0] :\n\t\t\t\tcoRNG = int( ( 1 - max( min ( value\[0].sample('alpha', samXY\[0], samXY\[1]) , 1.0 ) , 0.01 ) ) * 50 )\n\t\t\t\txRNG = \[ samXY\[0]-int(coRNG/2)+i for i in range( int(coRNG/2) ) ]\n\t\t\t\tyRNG = \[ samXY\[1]-int(coRNG/2)+i for i in range( int(coRNG/2) ) ]\n\t\t\t\tif not len( list( set( \[ i\[0] for i in p2Data ] ).intersection( xRNG ) ) ) :\n\t\t\t\t\tif not len( list( set( \[ i\[1] for i in p2Data ] ).intersection( yRNG ) ) ) :\n\t\t\t\t\t\tp2Data.append( samXY )\n\t\t\t\t\t\tcount += 1\n\t\t\t\t\telse :\n\t\t\t\t\t\tif subCount > _thisG\['fail_attempts'].getValue() :\n\t\t\t\t\t\t\tcount = value\[1]\n\t\t\t\t\t\tsubCount += 1\n\t\t\t\t\t#print (count)\n\n\t\tp2Data = \[ str( key.split('_')\[1] ) + '_' + str( p\[0] ) + '_' + str( p\[1] ) for p in p2Data ]\n\t\tpos2D += p2Data\n\n\tdel p2Data , coRNG , xRNG , yRNG , _thisG , _tileData\n\n\treturn pos2D" +STARTLINE}
  addUserKnob {22 fn02 -STARTLINE T "import math\n\ndef getLevel() :\n\t### level define ###\n\tif len(nuke.thisNode().fullName().split('.')) == 1 :\n\t\tggLevel = nuke.root()\n\telse :\n\t\tnodePath = nuke.thisNode().fullName().split('.')\n\t\tnodePath.pop()\n\t\tggLevel = nuke.toNode('.'.join(nodePath))\n\treturn ggLevel\n\n##########\n\ndef upstreamNodes( _startNode , _filterClass ) :\n\tmainStream = \[]\n\tcurNode = _startNode\n\twhile curNode :\n\t\tif curNode.knob('matrix') :\n\t\t\tif curNode.Class() in _filterClass :\n\t\t\t\tsubStream = \[curNode]\n\n\t\t\t\tfor x in range ( 1 , curNode.inputs() ) :\n\t\t\t\t\tsubNode = curNode.input(x)\n\t\t\t\t\tif subNode.knob('matrix') :\n\t\t\t\t\t\tsubStream.append( subNode )\n\n\t\t\t\t\twhile subNode :\n\t\t\t\t\t\tfor y in range ( 0 , subNode.inputs() ) :\n\t\t\t\t\t\t\tif subNode.input(y).knob('matrix') :\n\t\t\t\t\t\t\t\tsubStream.append( subNode.input(y) )\n\t\t\t\t\t\tsubNode = subNode.input( 0 )\n\n\t\t\t\tmainStream.append( subStream )\n\t\tcurNode = curNode.input( 0 )\n\n\tdel subStream , curNode, _startNode , _filterClass\n\n\treturn mainStream\n\n##########\n\ndef unify( _mainstream , _vtime ) :\n\n\t# check input node type ##########################################\n\tif _mainstream\[ len(_mainstream) - 1 ]\[0] in filterCheck :\n\t\t_mainstream.reverse()\n\n\toutMTX = nuke.math.Matrix4()\n\tfor a in range (0, len( _mainstream )) :\n\t\tfor b in range (0, len( _mainstream\[a] )) :\n\n\t\t\tgetMTX = nuke.math.Matrix4()\n\t\t\tfocusNode = _mainstream\[a]\[b]\n\n\t\t\tfor q in range (0,16) :\n\t\t\t\tgetMTX\[q] = focusNode.knob('matrix').getValueAt( _vtime )\[q]\n\n\t\t\tif a != 0 :\n\t\t\t\toutMTX = outMTX * getMTX\n\t\t\telse :\n\t\t\t\toutMTX = getMTX\n\n\treturn outMTX\n\n##########\n\ndef autoBackdrop_mod( _name , _tileC) : \n\tselNodes = nuke.selectedNodes() \n\t\n\t# Calculate bounds for the backdrop node. \n\tbdX = min(\[node.xpos() for node in selNodes]) \n\tbdY = min(\[node.ypos() for node in selNodes]) \n\tbdW = max(\[node.xpos() + node.screenWidth() for node in selNodes]) - bdX \n\tbdH = max(\[node.ypos() + node.screenHeight() for node in selNodes]) - bdY \n\n\t# Expand the bounds to leave a little border. Elements are offsets for left, top, right and bottom edges respectively \n\tleft, top, right, bottom = (-10, -80, 10, 10) \n\tbdX += left \n\tbdY += top \n\tbdW += (right - left) \n\tbdH += (bottom - top) \n\t\n\tn = nuke.nodes.BackdropNode(\n\t\t\tlabel = _name ,\n\t\t\txpos = bdX , \n\t\t\tbdwidth = bdW , \n\t\t\typos = bdY , \n\t\t\tbdheight = bdH , \n\t\t\ttile_color = _tileC , \n\t\t\tnote_font_size=42 , \n\t\t\t) \n\t\n\t# revert to previous selection \n\tn\['selected'].setValue(False) \n\t\n\treturn n\n\n##########\n\ndef mtx2value( _uMTX ) :\n\t_uMTX.transpose()\n\n\tmTranslate = nuke.math.Matrix4( _uMTX )\n\tmTranslate.translationOnly()\n\ttranslate = (mTranslate\[12], mTranslate\[13], mTranslate\[14])\n\n\tmRotate = nuke.math.Matrix4( _uMTX )\n\tmRotate.rotationOnly()\n\trotateRad = mRotate.rotationsZXY()\n\trotate = (math.degrees(rotateRad\[0]), math.degrees(rotateRad\[1]), math.degrees(rotateRad\[2]))\n\n\tmScale = nuke.math.Matrix4( _uMTX )\n\tmScale.scaleOnly()\n\tscale = (mScale.xAxis().x, mScale.yAxis().y, mScale.zAxis().z)\n\n\treturn ( translate, rotate, scale )"}
  addUserKnob {22 cpCode01 T "for node in nuke.allNodes() :\n    if node.name()\[0:3] == 'ax_' :\n        node\['gl_color'].setValue( int( nuke.thisGroup()\['display_color'].getValue() ) )" +STARTLINE}
  addUserKnob {22 cpCode02 -STARTLINE T "import math\n\nthisGRP = nuke.thisGroup()\n\ngoStore = nuke.toNode('store')\ngoStore\['fn'].execute()\n\nif thisGRP\['exTranslate'].value() or thisGRP\['exRotate'].value() or thisGRP\['exScale'].value() :\n\n\t##### get selected axis\n\tselAX = \[]\n\twith thisGRP :\n\t\tfor node in nuke.allNodes() :\n\t\t\tif node.name()\[0:3] == 'ax_' and node\['selected'].getValue() == 1 :\n\t\t\t\tselAX.append( node )\n\n\tif len(selAX) :\n\t\tspace = \[ int(nuke.toNode('preferences')\['GridWidth'].getValue()) , int(nuke.toNode('preferences')\['GridHeight'].getValue()) ]\n\n\t\tfilterCheck = goStore\['filterNonReverse'].getValue().split(',')\n\t\tfilter3DNodes = goStore\['filter3DNodes'].value().split(',')\n\t\texNodes = \[]\n\n\t\txportSC = nuke.nodes.Scene()\n\t\texNodes.append( xportSC )\n\n\t\tprogBar = nuke.ProgressTask('Extracting instances...')\n\t\tjobCount = 0\n\t\tjobTotal = len( selAX )\n\n\t\tcount = 0\n\t\tfor node in selAX :\n\t\t\t### progress bar\n\t\t\tjobCount += 1\n\t\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\t\tif progBar.isCancelled() :\n\t\t\t\tbreak;\n\t\t\tprogBar.setProgress(progShow)\n\t\t\t#################\n\n\t\t\ttry :\n\t\t\t\texColor = thisGRP\['exColor'].value()\n\t\t\texcept :\n\t\t\t\texColor = False\n\n\t\t\tif exColor :\n\t\t\t\txportAX = nuke.nodes.Axis(\n\t\t\t\t\t\t\t\txpos = int( thisGRP.xpos() + space\[0] * ( count + 1 ) ) , \n\t\t\t\t\t\t\t\typos = int( thisGRP.ypos() + space\[1] )\n\t\t\t\t\t\t\t\t)\n\t\t\t\txportMULT = nuke.nodes.Multiply(\n\t\t\t\t\t\t\t\tchannels = 'rgb' ,\n\t\t\t\t\t\t\t\txpos = int( thisGRP.xpos() + space\[0] * ( count + 1 ) ) , \n\t\t\t\t\t\t\t\typos = int( thisGRP.ypos() )\n\t\t\t\t\t\t\t\t)\n\t\t\t\txportMULT\['value'].setSingleValue(False)\n\t\t\t\twith thisGRP :\n\t\t\t\t\txportMULT\['value'].setValue( nuke.toNode( 'cc_\{0\}'.format(node.name()\[3:]) )\['value'].getValue() )\n\t\t\t\texNodes.append( xportAX )\n\t\t\t\texNodes.append( xportMULT )\n\t\t\telse :\n\t\t\t\txportAX = nuke.nodes.Axis(\n\t\t\t\t\txpos = int( thisGRP.xpos() + space\[0] * ( count + 1 ) ) , \n\t\t\t\t\typos = int( thisGRP.ypos() )\n\t\t\t\t\t)\n\t\t\t\texNodes.append( xportAX )\n\n\t\t\txportSC.setInput( count, xportAX )\n\t\t\tcount += 1\n\n\t\t\ttry :\n\t\t\t\twith thisGRP :\n\t\t\t\t\tAnimRange = \[int(i) for i in goStore\['aniRNG'].value().split('-')]\n\n\t\t\t\tif thisGRP\['exTranslate'].value() :\n\t\t\t\t\txportAX\['translate'].setAnimated()\n\t\t\t\tif thisGRP\['exRotate'].value() :\n\t\t\t\t\txportAX\['rotate'].setAnimated()\n\t\t\t\tif thisGRP\['exScale'].value() :\n\t\t\t\t\txportAX\['scaling'].setAnimated()\n\n\t\t\t\tfor ctime in xrange( int(AnimRange\[0]) , int(AnimRange\[1]+1) , 1  ) :\n\t\t\t\t\tmainstream = upstreamNodes( node , filter3DNodes )\n\t\t\t\t\tmMTX = unify( mainstream , ctime )\n\t\t\t\t\tform = mtx2value( mMTX )\n\n\t\t\t\t\tif thisGRP\['exTranslate'].value() :\n\t\t\t\t\t\tfor i in range( 3 ) :\n\t\t\t\t\t\t\txportAX\['translate'].setValueAt( form\[0]\[i] , ctime, i )\n\t\t\t\t\tif thisGRP\['exRotate'].value() :\n\t\t\t\t\t\tfor i in range( 3 ) :\n\t\t\t\t\t\t\txportAX\['rotate'].setValueAt( form\[1]\[i] , ctime, i )\n\t\t\t\t\tif thisGRP\['exScale'].value() :\n\t\t\t\t\t\tfor i in range( 3 ) :\n\t\t\t\t\t\t\txportAX\['scaling'].setValueAt( form\[2]\[i] , ctime, i )\n\t\t\texcept :\n\t\t\t\tmainstream = upstreamNodes( node , filter3DNodes )\n\t\t\t\tmMTX = unify( mainstream , nuke.frame() )\n\t\t\t\tform = mtx2value( mMTX )\n\n\t\t\t\tif thisGRP\['exTranslate'].value() :\n\t\t\t\t\txportAX\['translate'].setValue( form\[0] )\n\t\t\t\tif thisGRP\['exRotate'].value() :\n\t\t\t\t\txportAX\['rotate'].setValue( form\[1] )\n\t\t\t\tif thisGRP\['exScale'].value() :\n\t\t\t\t\txportAX\['scaling'].setValue( form\[2] )\n\n\t\t##### deselect all Nodes\n\t\twith getLevel() :\n\t\t\tsavedSelected = \[]\n\t\t\tfor node in nuke.allNodes() :\n\t\t\t\tif node\['selected'].value()\t:\n\t\t\t\t\tsavedSelected.append( node )\n\t\t\t\tnode.setSelected( False )\n\n\t\t##### set backdrop\n\t\tfor node in exNodes :\n\t\t\tnode.setSelected( True )\n\n\t\tautoBackdrop_mod( thisGRP.name() , int( thisGRP\['tile_color'].getValue() ) )\n\n\t\tfor node in exNodes :\n\t\t\tnode.setSelected( False )\n\n\t\t##### restore selected node\n\t\tfor node in savedSelected :\n\t\t\tnode.setSelected( True )\n\n\t\tdel progBar, jobCount, jobTotal, progShow\n\t\t\n\telse :\n\t\tnuke.message('No selected axis found.<br><br>Process denied...')\n\nelse :\n\tnuke.message('No translate, rotate and scale checked, no axis will be extract.<br><br>Process denied...')"}
  addUserKnob {22 cpCode03 T "selAX = \[]\nfor node in nuke.allNodes('Axis') :\n\tif node.name()\[:3] == 'ax_' and node\['selected'].getValue() :\n\t\tfor link in node.dependent()\[0].dependencies() :\n\t\t\tif link.Class() != 'Input' :\n\t\t\t\tselAX.append( link )\n\t\tif node.dependent()\[0].dependent()\[0].Class() == 'ApplyMaterial' :\n\t\t\tfor link in node.dependent()\[0].dependent()\[0].dependencies() :\n\t\t\t\tselAX.append( link )\n\t\t\tselAX.append( node.dependent()\[0].dependent()\[0] )\n\t\telse :\n\t\t\tselAX.append( node.dependent()\[0] )\n\nif len( selAX ) :\n\tprogBar = nuke.ProgressTask('Removing instances...')\n\tjobCount = 0\n\tjobTotal = len( selAX )\n\n\tfor rmNode in selAX :\n\t\t### progress bar\n\t\tjobCount += 1\n\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\tif progBar.isCancelled() :\n\t\t\tbreak;\n\t\tprogBar.setProgress(progShow)\n\t\t#################\n\n\t\tfor i in range( rmNode.inputs() ) :\n\t\t\trmNode.setInput( i, None )\n\t\tif rmNode.Class() == 'Axis' :\n\t\t\tnuke.thisGroup()\['info_inst'].setValue( str( int( nuke.thisGroup()\['info_inst'].value() ) -1 ) )\n\t\tnuke.delete( rmNode )\n\n\tdel progBar, jobCount, jobTotal, progShow\nelse :\n\tnuke.message('No instance selected. Nothing deleted.')" +STARTLINE}
  addUserKnob {43 filterNonReverse +DISABLED}
  filterNonReverse Camera,Camera2,Light,Light2,DirectLight,Environment,Axis,Axis2
  addUserKnob {43 filter3DNodes +DISABLED}
  filter3DNodes Axis,Axis2,Card,Card2,Cube,Cylinder,Sphere,ReadGeo,ReadGeo2,Light,Light2,DirectLight,Spotlight,Environment,TransformGeo,EditGeo,Camera,Camera2
  addUserKnob {43 filterPrimitives +DISABLED}
  filterPrimitives Card,Card2,Cube,Cylinder,Sphere,ReadGeo,ReadGeo2
 }
 NoOp {
  inputs 0
  name menu02
  knobChanged "\nthisGRP = nuke.thisGroup()\ndmapknobs = \['title_dmap_setting','uv_type','sample_res','max_instance','dmap_seed','rgb_color','fail_attempts']\nvtxknobs = \['title_vf_setting','random_percentage','random_seed']\nif thisGRP\['snap_type'].getValue() :\n    for knob in dmapknobs :\n        thisGRP\[knob].setEnabled( True )\n    for knob in vtxknobs :\n        thisGRP\[knob].setEnabled( False )\n    thisGRP\['selected_vertex_info'].setEnabled( False )\nelse :\n    for knob in dmapknobs :\n        thisGRP\[knob].setEnabled( False )\n    for knob in vtxknobs :\n        thisGRP\[knob].setEnabled( True )\n    thisGRP\['selected_vertex_info'].setEnabled( True )\n"
  xpos -447
  ypos 127
  addUserKnob {20 User}
  addUserKnob {4 snap_type l "snap type" M {"selected vertices/faces" "density map (alpha)"}}
 }
push $N1e37b800
 GeoSelect {
  selectable false
  geo {  }
  name GeoSelect
  xpos 138
  ypos 215
 }
 Output {
  name Output1
  xpos 138
  ypos 724
 }
end_group
