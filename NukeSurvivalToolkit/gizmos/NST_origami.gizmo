Group {
 name origami
 onCreate "\nnuke.toNode('store')\['fn'].execute()\n"
 tile_color 0xd2d794ff
 addUserKnob {20 tab_general l General}
 addUserKnob {41 frame_range l "frame range" t "The frame range setting will applied on <b>'create target set'</b> and <b>'Deform with animation'</b>\n\nproject setting : frame range will be set to project setting of the script.\n\ncustom : will enable custom range knobs." T menu01.frame_range}
 addUserKnob {3 firstFR l "custom range" t "First frame of the custom frame range." +DISABLED}
 firstFR 1001
 addUserKnob {3 lastFR l "" t "Last frame of the custom frame range." -STARTLINE +DISABLED}
 lastFR 1100
 addUserKnob {20 origamiTabStart l "" +STARTLINE n -2}
 addUserKnob {20 tab_set l Set}
 addUserKnob {26 title_target l "<b>Target Geo Setup</b>"}
 addUserKnob {41 tgt_gl_color l "Target Display Color" T targetView3d.tgt_gl_color}
 addUserKnob {7 tgt_scale l scale t "Scale of the target set in 3D view. Update in real-time." R 0.001 4}
 tgt_scale 0.5
 addUserKnob {22 create_tgt_set l "Create Target Set" t "Create target set from selected vertex. Required geo connected to <b>target input</b>. This is the first step of the using the this tool." T "thisGRP = nuke.thisGroup()\ngoStore = nuke.toNode('store')\ngoStore\['fn'].execute()\n\ntemp = \[]\nselv =\[]\nfor i in nukescripts.snap3d.selectedVertexInfos () :\n\ttemp = \[i.index, i.position]\n\tif selv.count(temp) == 0 :\n\t\tselv.append(temp)\ndel temp\n\nif len(selv) < 1 or thisGRP.input(0) == None :\n\tnuke.message('Please connect the target geo to this node and select vertex first.')\nelse :\n\tthisGRP\['reset_tgt'].execute()\n\n\tFRsetting = thisGRP\['frame_range'].getValue()\n\n\tif FRsetting == 1 :\n\t\tframeST = int(thisGRP\['firstFR'].getValue())\n\t\tframeED = int(thisGRP\['lastFR'].getValue())\n\telse :\n\t\tframeST = nuke.root().firstFrame()\n\t\tframeED = nuke.root().lastFrame()\n\n\tgetColor = thisGRP\['tgt_gl_color'].getValue()\n\n\toSC = nuke.toNode('oScene')\n\n\ttgtGRP = nuke.nodes.Group(name='t')\n\n\ttgtGRP.begin()\n\ttgtSC = nuke.nodes.Scene()\n\ttgtOUT = nuke.nodes.Output()\n\ttgtOUT.setInput(0, tgtSC)\n\n\tfor i in range (0, len(selv)) :\n\t\ttgtAX = nuke.nodes.Axis(name='x' + str(i))\n\t\ttgtAX.addKnob(nuke.XYZ_Knob('origin'))\n\t\ttgtAX\['origin'].setAnimated()\n\t\ttgtAX\['translate'].setAnimated()\n\t\ttgtAX\['gl_color'].fromScript('0x%02x%02x%02x%02x' % (getColor\[0]*255 , getColor\[1]*255, getColor\[2]*255, 255))\n\t\ttgtAX\['scaling'].setExpression('parent.parent.tgt_scale')\n\t\ttgtSC.setInput(i, tgtAX)\n\n\thack_ct = nuke.nodes.CurveTool()\n\n\tprogBar = nuke.ProgressTask('Sampling vertex')\n\tjobCount = 0\n\tjobTotal = (frameED+1)-frameST\n\n\tfor time in xrange (int(frameST), int(frameED+1), 1) :\n\t\tnuke.execute(hack_ct, time, time)\n\t\t### progress bar\n\t\tjobCount += 1\n\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\tif progBar.isCancelled() :\n\t\t\tbreak;\n\t\tprogBar.setProgress(progShow)\n\t\t#################\n\n\t\tselv = \[]\n\t\tg = 0\n\t\tfor i in nukescripts.snap3d.selectedVertexInfos () :\n\t\t\ttemp = \[i.index, i.position]\n\t\t\tif selv.count(temp) == 0 :\n\t\t\t\tselv.append(temp)\n\n\t\t\t\tfocusNODE = nuke.toNode('x' + str(g))\n\t\t\t\tfocusNODE\['origin'].setValue(i.position)\n\t\t\t\tfocusNODE\['translate'].setValue(i.position)\n\t\t\t\tif time == int(frameED) :\n\t\t\t\t\tfocusNODE\['knobChanged'].setValue('targetLock(nuke.thisNode())')\n\t\t\t\tg += 1\n\n\tdel progBar\n\tdel temp\n\tnuke.delete(hack_ct)\n\ttgtGRP.end()\n\toSC.setInput(3, tgtGRP)\ndel selv" +STARTLINE}
 addUserKnob {22 add_ex_tgt l "Add Extra Target" t "User can add extra target set after the set created. The extra target can be any 3D nodes or vertex selected in viewer.\n\nnode : select all the 3D nodes you want to add and click this button. It will import the animated nodes into the target set.\n\nvertex : select vertex in viewer and click this button. It will scan through the frame range and import the vertex into the target set." T "if nuke.toNode('t') == None :\n\tnuke.message('No Target Selection found. Please create target selection first before add extra target.')\nelse :\n\n\tthisGRP = nuke.thisGroup()\n\texfr = thisGRP\['extra_from'].getValue()\n\n\tgoStore = nuke.toNode('store')\n\tfilter3DNodes = goStore\['filter3DNodes'].getValue()\n\troot = getLevel()\n\n\tselEx = \[]\n\n\troot.begin()\n\tif exfr == 0 :\n\t\tfor node in nuke.selectedNodes() :\n\t\t\tif filter3DNodes.count(node.Class()) != 0 :\n\t\t\t\tselEx.append(node)\n\t\tif len(selEx) == 0 :\n\t\t\tnuke.message('No available node selected. Only 3D nodes supported.')\n\telse :\n\t\tfor i in nukescripts.snap3d.selectedVertexInfos () :\n\t\t\ttemp = \[i.index, i.position]\n\t\t\tif selEx.count(temp) == 0 :\n\t\t\t\tselEx.append(temp)\n\t\tif len(selEx) == 0 :\n\t\t\tnuke.message('No vertex selected.')\n\troot.end()\n\n\tthisGRP.begin()\n\tif len(selEx) != 0 :\n\t\ttgtGRP = nuke.toNode('t')\n\t\tgetColor = thisGRP\['tgt_gl_color'].getValue()\n\n\t\tFRsetting = thisGRP\['frame_range'].getValue()\n\n\t\tif FRsetting == 1 :\n\t\t\tframeST = int(thisGRP\['firstFR'].getValue())\n\t\t\tframeED = int(thisGRP\['lastFR'].getValue())\n\t\telse :\n\t\t\tframeST = nuke.root().firstFrame()\n\t\t\tframeED = nuke.root().lastFrame()\n\n\t\t##########################################\n\n\t\tnumName = \[]\n\n\t\ttgtGRP.begin()\n\t\tfor node in nuke.allNodes() :\n\t\t\tif node.Class()\[0:4] == 'Axis' :\n\t\t\t\tnumName.append(int(node.name()\[1:]))\n\t\t\tif node.Class()\[0:5] == 'Scene' :\n\t\t\t\tscNode = node\n\n\t\t##########################################\n\n\t\tcountCheck = 0\n\t\ttempKeep = 0\n\t\tnumNameNew = \[]\n\n\t\twhile countCheck < len(selEx) :\n\t\t\twhile numName.count(tempKeep) != 0 :\n\t\t\t\ttempKeep += 1\n\t\t\tnumName.append(tempKeep)\n\t\t\tnumNameNew.append(tempKeep)\n\t\t\tcountCheck += 1\n\n\t\tdel tempKeep\n\t\tdel numName\n\n\t\t##########################################\n\n\t\tfor i in range (0, len(selEx)) :\n\t\t\tnewAX = nuke.nodes.Axis(name='x' + str(numNameNew\[i]))\n\t\t\tnewAX.addKnob(nuke.XYZ_Knob('origin'))\n\t\t\tnewAX\['origin'].setAnimated()\n\t\t\tnewAX\['translate'].setAnimated()\n\t\t\tnewAX\['gl_color'].fromScript('0x%02x%02x%02x%02x' % (getColor\[0]*255 , getColor\[1]*255, getColor\[2]*255, 255))\n\t\t\tnewAX\['scaling'].setExpression('parent.parent.tgt_scale')\n\t\t\tscNode.setInput(scNode.inputs()+1+i, newAX)\n\n\t\tif exfr == 0 :\n\t\t\tfor time in xrange (int(frameST), int(frameED+1), 1) :\n\n\t\t\t\tfor i in range (0, len(numNameNew)) :\n\t\t\t\t\tfocusNODE = nuke.toNode('x' + str(numNameNew\[i]))\n\t\t\t\t\tfocusNODE\['origin'].setValueAt(selEx\[i]\['translate'].getValueAt(time)\[0], time, 0)\n\t\t\t\t\tfocusNODE\['origin'].setValueAt(selEx\[i]\['translate'].getValueAt(time)\[1], time, 1)\n\t\t\t\t\tfocusNODE\['origin'].setValueAt(selEx\[i]\['translate'].getValueAt(time)\[2], time, 2)\n\t\t\t\t\tfocusNODE\['translate'].setValueAt(selEx\[i]\['translate'].getValueAt(time)\[0], time, 0)\n\t\t\t\t\tfocusNODE\['translate'].setValueAt(selEx\[i]\['translate'].getValueAt(time)\[1], time, 1)\n\t\t\t\t\tfocusNODE\['translate'].setValueAt(selEx\[i]\['translate'].getValueAt(time)\[2], time, 2)\n\t\t\t\t\tif time == int(frameED) :\n\t\t\t\t\t\tfocusNODE\['knobChanged'].setValue('targetLock(nuke.thisNode())')\n\t\telse :\n\t\t\thack_ct = nuke.nodes.CurveTool()\n\n\t\t\tprogBar = nuke.ProgressTask('Sampling vertex')\n\t\t\tjobCount = 0\n\t\t\tjobTotal = (frameED+1)-frameST\n\n\t\t\tfor time in xrange (int(frameST), int(frameED+1), 1) :\n\t\t\t\tnuke.execute(hack_ct, time, time)\n\t\t\t\t### progress bar\n\t\t\t\tjobCount += 1\n\t\t\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\t\t\tif progBar.isCancelled() :\n\t\t\t\t\tbreak;\n\t\t\t\tprogBar.setProgress(progShow)\n\t\t\t\t#################\n\n\t\t\t\tselv = \[]\n\t\t\t\tg = 0\n\t\t\t\tfor i in nukescripts.snap3d.selectedVertexInfos () :\n\t\t\t\t\ttemp = \[i.index, i.position]\n\t\t\t\t\tif selv.count(temp) == 0 :\n\t\t\t\t\t\tselv.append(temp)\n\n\t\t\t\t\t\tfocusNODE = nuke.toNode('x' + str(numNameNew\[g]))\n\t\t\t\t\t\tfocusNODE\['origin'].setValue(i.position)\n\t\t\t\t\t\tfocusNODE\['translate'].setValue(i.position)\n\t\t\t\t\t\tif time == int(frameED) :\n\t\t\t\t\t\t\tfocusNODE\['knobChanged'].setValue('targetLock(nuke.thisNode())')\n\t\t\t\t\t\tg += 1\n\n\t\t\tdel progBar, temp\n\t\t\tnuke.delete(hack_ct)\n\n\t\ttgtGRP.end()\n\n\tdel selEx" +STARTLINE}
 addUserKnob {4 extra_from l "Extra from" -STARTLINE M {nodes vertex "" "" "" ""}}
 addUserKnob {22 reset_tgt l Remove t "Remove any exisiting target set." T "try :\n\tnuke.delete(nuke.toNode('t'))\n\tnuke.thisGroup()\['metadata'].fromScript('')\n\tthisGRP\['reset_deform'].execute()\nexcept :\n\tpass" +STARTLINE}
 addUserKnob {26 title_source l "<b>Source Geo Setup</b>"}
 addUserKnob {41 src_gl_color l "Source Display Color" T sourceView3d.src_gl_color}
 addUserKnob {7 src_scale l scale t "Scale of the source set in 3D view. Update in real-time." R 0.001 4}
 src_scale 1
 addUserKnob {6 use_card_deform l "use card deform" t "Use card deform function. Source input MUST be <b>'Card2'</b> node (nuke default card node).\n\nDuring create source set, will confirm with user of the control points detected from the source input. <b>Required at least 3x3 size.</b>\n\nAfter source set created, this knob will be locked and not changable unless remove the source set again. The tool will take over the setting of the card. If change any setting of the source geo, the function will not work properly." +STARTLINE}
 use_card_deform true
 addUserKnob {22 create_src_set l "Create Source Set" t "If <b>'use card deform'</b> is uncheck, the tool will create source set base on the vertex of the source geo.\n\nIf <b>'use card deform'</b> is checked, the tool will confirm the amount of control points with user. And create the source set base on control point had been set." T "thisGRP = nuke.thisGroup()\ngoStore = nuke.toNode('store')\ngoStore\['fn'].execute()\n\nif thisGRP.input(1) == None :\n  nuke.message('Please connect the source geo to this node first.')\nelse :\n  inMTX = thisGRP.input(1)\['matrix'].getValue()\n\n  vertexT = \{\}\n\n  srcGeo = thisGRP.input(1)\n\n  if thisGRP\['use_card_deform'].getValue() != 1 :\n    thisGRP\['reset_src'].execute()\n\n    nuke.toNode('EditGeo_deform')\['disable'].setValue(0)\n    if thisGRP.input(1).Class() == 'Card2' :\n      srcGeo\['type'].setValue('none')\n\n    pgeoSGet = nuke.toNode('pgeoSGet')\n    vertexT = pgVertexPack(pgeoSGet)\n\n    ##############################################\n\n    createSRCset(vertexT, inMTX, thisGRP)\n    thisGRP\['use_card_deform'].setEnabled(False)\n  else :\n    if srcGeo.Class() == 'Card2' :\n      thisGRP\['reset_src'].execute()\n\n      thisGRP\['export'].setEnabled(False)\n      nuke.toNode('EditGeo_deform')\['disable'].setValue(1)\n      \n      srcGeo\['type'].setValue('bicubic')\n      srcGeo\['break_tangent'].setValue(True)\n      rawData = srcGeo\['control_points'].toScript()\n\n      wSub = int(rawData.split(' ')\[2])\n      hSub = int(rawData.split(' ')\[1])\n\n      p = nuke.Panel('Control Points Confirm')\n      p.addSingleLineInput('x points', str(wSub))\n      p.addSingleLineInput('y points', str(hSub))\n\n      if p.show() == 1 :\n        xInput = int(p.value('x points'))\n        yInput = int(p.value('y points'))\n        if xInput == wSub and yInput == hSub :\n          nuke.toNode('dataset')\['raw_cdd'].setValue( rawData )\n\n          import re\n          originData = re.split( '\{|\}', rawData )\n          if originData.count('curve') != 0 :\n            srcGeo\['del_anim_shape'].execute()\n\n          ctrlpts = getCTRLPTS(rawData)\n\n          for i in range (0, len(ctrlpts)) :\n            vertexT\[i] = ctrlpts\[i]\n\n          ##############################################\n\n          createSRCset(vertexT, inMTX, thisGRP)\n        else :\n          srcGeo\['x_points'].setValue( xInput )\n          srcGeo\['y_points'].setValue( yInput )\n          srcGeo.showControlPanel()\n          srcGeo\['new_shape'].execute()\n          srcGeo.hideControlPanel()\n\n          rawData = srcGeo\['control_points'].toScript()\n          nuke.toNode('dataset')\['raw_cdd'].setValue( rawData )\n\n          import re\n          originData = re.split( '\{|\}', rawData )\n          if originData.count('curve') != 0 :\n            srcGeo\['del_anim_shape'].execute()\n\n          ctrlpts = getCTRLPTS(rawData)\n\n          for i in range (0, len(ctrlpts)) :\n            vertexT\[i] = ctrlpts\[i]\n\n          ##############################################\n\n          createSRCset(vertexT, inMTX, thisGRP)\n\n        thisGRP\['use_card_deform'].setEnabled(False)\n    else :\n      nuke.message('Source input no Card2 found.')" +STARTLINE}
 addUserKnob {22 reset_src l Remove t "Remove any exisiting source set, reset all the deform value and release 'use card deform' knob." T "try :\n\tthisGRP = nuke.thisGroup()\n\tnuke.delete(nuke.toNode('s'))\n\tthisGRP\['metadata'].fromScript('')\n\tthisGRP\['use_card_deform'].setEnabled(True)\n\tthisGRP\['reset_deform'].execute()\n\tnuke.toNode('dataset')\['raw_cdd'].setValue('')\n\tthisGRP\['export'].setEnabled(True)\nexcept :\n\tpass" +STARTLINE}
 addUserKnob {26 title_p2p l "<b>Point-to-Point Setup</b>"}
 addUserKnob {22 snap l "Snap Source to Target" t "Required select one target and one source under view and snap them together. All data will store into <b>'Point-to-Point data'</b> (metadata)." T "if nuke.toNode('t') == None :\n\tnuke.message('Missing Target selection. Please process \"Create Target Selection\" first.')\nelse :\n\tif nuke.toNode('s') == None :\n\t\tnuke.message('Missing Source UI. Please process \"Create Source UI\" first.')\n\telse :\n\t\ttry :\n\t\t\tthisGRP = nuke.thisGroup()\n\t\t\tgoStore = nuke.toNode('store')\n\t\t\tgoStore\['fn'].execute()\n\n\t\t\ttgtGRP = nuke.toNode('t')\n\t\t\tsrcGRP = nuke.toNode('s')\n\n\t\t\ttgtGRP.begin()\n\t\t\tfor node in nuke.allNodes() :\n\t\t\t\tif node\['selected'].getValue() == 1 :\n\t\t\t\t\ttgtSel = node\n\t\t\ttgtGRP.end()\n\n\t\t\tsrcGRP.begin()\n\t\t\tfor node in nuke.allNodes() :\n\t\t\t\tif node\['selected'].getValue() == 1 :\n\t\t\t\t\tsrcSel = node\n\t\t\tsrcGRP.end()\n\n\t\t\tsrcSel\['translate'].setValue(tgtSel\['translate'].getValue())\n\n\t\t\t#######################################################\n\n\t\t\tpathLength = len(srcSel.fullName().split('.'))\n\t\t\tsrcName = '.'.join(srcSel.fullName().split('.')\[pathLength-2:pathLength])\n\t\t\ttgtName = '.'.join(tgtSel.fullName().split('.')\[pathLength-2:pathLength])\n\n\t\t\texistDataset = getData(thisGRP)\n\n\t\t\texistDataset\[srcName] = tgtName\n\n\t\t\tnewData = \[]\n\t\t\tfor key in existDataset :\n\t\t\t\tnewData.append('\{set ' + str(key) + ' ' + str(existDataset\[key]) + '\}')\n\n\t\t\tthisGRP\['metadata'].fromScript('\\n'.join(newData))\n\t\t\tdel existDataset\n\t\texcept :\n\t\t\tnuke.message('Process fail. Please select 1 target and 1 source first.')" +STARTLINE}
 addUserKnob {22 deselect_all l "Deselect All" t "This tool designed to only able select one target and one source only. User cannot de-select under viewer. Use this button to de-select any target or source." -STARTLINE T "try :\n\taxGRP = nuke.toNode('t')\n\taxGRP.begin()\n\tfor node in nuke.allNodes() :\n\t\tnode\['selected'].setValue(0)\n\taxGRP.end()\n\taxGRP = nuke.toNode('s')\n\taxGRP.begin()\n\tfor node in nuke.allNodes() :\n\t\tnode\['selected'].setValue(0)\n\taxGRP.end()\nexcept :\n\tpass"}
 addUserKnob {20 pts2pts l "Point-to-Point data" n 1}
 pts2pts 0
 addUserKnob {41 metadata l "" t "<b>*If not sure how this work, don't change it manually. Let the tool handle this.*</b>\nThis store the point-to-point data after trigger snap function. It store the full path of the target set and the source set. User can find those full path name under viewer.\n\nFor example :\norigami.s.y.1 - for the source\norigami.t.x.1 - for the target\n\nIf these appear in the same line, which means s.y.1 linked to t.x.1 . Once triggered deform, the deformation will base on this point-to-point data to deform the point.\n\nSorting order will not affect anyting on the result. If add the data manually, need to be sure the full path name is existing in the set. Otherwise that will break the function." -STARTLINE T dataset.metadata}
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 tab_cardDeform l "Card Deform"}
 addUserKnob {26 title_subd l <b>Subdivision</b>}
 addUserKnob {41 rows l rows/columns T menu04.rows}
 addUserKnob {41 columns l "" -STARTLINE T menu04.columns}
 addUserKnob {26 title_tangent l <b>Tangent</b>}
 addUserKnob {41 live_update l "live update" T menu02.live_update}
 addUserKnob {41 t1angle l "tangent +x" T menu03.t1angle}
 addUserKnob {41 t1scale l scale -STARTLINE T menu03.t1scale}
 addUserKnob {41 t2angle l "tangent -x" T menu03.t2angle}
 addUserKnob {41 t2scale l scale -STARTLINE T menu03.t2scale}
 addUserKnob {41 t3angle l "tangent +y" T menu03.t3angle}
 addUserKnob {41 t3scale l scale -STARTLINE T menu03.t3scale}
 addUserKnob {41 t4angle l "tangent -y" T menu03.t4angle}
 addUserKnob {41 t4scale l scale -STARTLINE T menu03.t4scale}
 addUserKnob {41 edge_tangent l "edge tangent" T menu03.edge_tangent}
 addUserKnob {26 title_animT l "Animate Tangent"}
 addUserKnob {41 anim_type_tangent l "anim type" t "Anim type of tangent will ONLY apply on <b>deform with animation</b> .\n\n<b>dynamic</b>\nCalculate every tangent angle and length on every frame.\n\n<b>static</b>\nOnly apply the tangent angle and length from the reference frame set in this tool.\n\nWhen the type set to static, <b>reference frame</b> knob will be enable.\n\nThis knob will not trigger 'live update' due to static option require within frame range." T menu05.anim_type_tangent}
 addUserKnob {3 ref_frame l "reference frame" t "This knob will be enable when tangent anim type set to <b>static</b>. And the tangle calculation will only apply from reference frame. The value has to be inside the frame range. " +DISABLED}
 ref_frame 1001
 addUserKnob {20 origamiTabEnd l "" +STARTLINE n -3}
 addUserKnob {26 ""}
 addUserKnob {6 deform_anim l "with Animation" t "Deform with animation." +STARTLINE}
 addUserKnob {22 deform l "                          Deform                           " t "Deform the source geo. It can be use as preview during process and also final deform." T "thisGRP = nuke.thisGroup()\nwAnim = thisGRP\['deform_anim'].getValue()\ngoStore = nuke.toNode('store')\ngoStore\['fn'].execute()\nthisGRP\['deform_status'].setValue(1)\n\nif thisGRP\['use_card_deform'].getValue() != 1 :\n\tegDeform = nuke.toNode('EditGeo_deform')\n\n\tmd = getData(thisGRP)\n\n\tdkeys = \[]\n\tdvalues = \[]\n\n\tif wAnim == 0 :\n\t\tfor key in md :\n\t\t\tdkeys.append(str(key\[3:]))\n\t\t\tfor i in range (0, 3) :\n\t\t\t\tdiff = nuke.toNode(md\[key])\['translate'].getValue()\[i] - nuke.toNode(key)\['origin'].getValue()\[i]\n\t\t\t\tdvalues.append(str(diff))\n\n\t\tegDeform\['keys'].fromScript('\{ ' + ' '.join(dkeys) + ' \}')\n\t\tegDeform\['values'].fromScript('\{ ' + ' '.join(dvalues) + ' \}')\n\n\telse :\n\t\tFRsetting = thisGRP\['frame_range'].getValue()\n\n\t\tif FRsetting == 1 :\n\t\t\tframeST = int(thisGRP\['firstFR'].getValue())\n\t\t\tframeED = int(thisGRP\['lastFR'].getValue())\n\t\telse :\n\t\t\tframeST = nuke.root().firstFrame()\n\t\t\tframeED = nuke.root().lastFrame()\n\n\t\t##########################################\n\n\t\ttempKeys01 = \[]\n\t\tfor key in md :\n\t\t\ttempKeys01.append(str(key\[3:]))\n\n\t\ttempKeys02 = \[]\n\t\tfor i in range (0, len(tempKeys01)) :\n\t\t\ttempKeep = \[]\n\t\t\tfor time in xrange (int(frameST), int(frameED+1), 1) :\n\t\t\t\ttempKeep.append('x' + str(time) + ' ' + tempKeys01\[i])\n\t\t\ttempKeys02.append(tempKeep)\n\t\t\tdel tempKeep\n\t\tdel tempKeys01\n\t\ttempKeys01 = \[]\n\t\tfor i in range (0, len(tempKeys02)) :\n\t\t\ttempKeys01.append('\{curve ' + ' '.join(tempKeys02\[i]) + '\}')\n\t\tdel tempKeys02\n\n\t\tdkeys = '\{' + ' '.join(tempKeys01) + '\}'\n\n\t\t##########################################\n\n\t\ttempValue01 = \[]\n\t\tfor key in md :\n\t\t\ttempValue03 = \[]\n\t\t\tfor time in xrange (int(frameST), int(frameED+1), 1) :\n\t\t\t\ttempValue02 = \[]\n\t\t\t\tfor i in range (0, 3) :\n\t\t\t\t\tdiff = nuke.toNode(md\[key])\['translate'].getValueAt(time)\[i] - nuke.toNode(key)\['origin'].getValue()\[i]\n\t\t\t\t\ttempValue02.append('x' + str(time) + ' ' + str(diff))\n\t\t\t\ttempValue03.append(tempValue02)\n\t\t\ttempValue01.append(tempValue03)\n\t\ttempValue02 = \[]\n\t\tfor i in range (0, len(tempValue01)) :\n\t\t\ttempX = \[]\n\t\t\ttempY = \[]\n\t\t\ttempZ = \[]\n\t\t\tfor t in range (0, len(tempValue01\[i])) :\n\t\t\t\ttempX.append(tempValue01\[i]\[t]\[0])\n\t\t\t\ttempY.append(tempValue01\[i]\[t]\[1])\n\t\t\t\ttempZ.append(tempValue01\[i]\[t]\[2])\n\t\t\ttempValue02.append('\{curve ' + ' '.join(tempX) + '\} \{curve ' + ' '.join(tempY) + '\} \{curve ' + ' '.join(tempZ) + '\}')\n\n\t\tdvalues = '\{' + ' '.join(tempValue02) + '\}'\n\n\t\tegDeform\['keys'].fromScript(dkeys)\n\t\tegDeform\['values'].fromScript(dvalues)\nelse :\n\tcardCenter(thisGRP, thisGRP.input(1))" +STARTLINE}
 addUserKnob {22 export l "     Export EditGeo     " t "Deformation can be export to EditGeo node but not for card deform." T "thisGRP = nuke.thisGroup()\negDeform = nuke.toNode('EditGeo_deform')\nroot = getLevel()\n\nroot.begin()\nexEG = nuke.nodes.EditGeo()\nexEG\['xpos'].setValue(thisGRP.xpos()+120)\nexEG\['ypos'].setValue(thisGRP.ypos())\nexEG\['label'].setValue('Export by Origami')\nexEG\['keys'].fromScript(egDeform\['keys'].toScript())\nexEG\['values'].fromScript(egDeform\['values'].toScript())\nexEG\['tile_color'].fromScript(thisGRP\['tile_color'].toScript())\nroot.end()" +STARTLINE}
 addUserKnob {22 reset_deform l "     Reset Deform     " t "Remove all the applied deformation data." -STARTLINE T "thisGRP = nuke.thisGroup()\nnuke.toNode('EditGeo_deform')\['keys'].fromScript('')\nnuke.toNode('EditGeo_deform')\['values'].fromScript('')\ntry :\n\tif thisGRP\['use_card_deform'].getValue() == 1 :\n\t\tthisGRP.input(1)\['useMatrix'].setValue(0)\n\t\tthisGRP.input(1)\['control_points'].fromScript(nuke.toNode('dataset')\['raw_cdd'].getValue())\n\t\tthisGRP.input(1)\['label'].setValue('')\n\t\tthisGRP.input(1)\['tile_color'].fromScript('0')\n\t\tthisGRP\['deform_status'].setValue(0)\nexcept :\n\tpass"}
 addUserKnob {3 deform_status l "" t "not for user" +STARTLINE +INVISIBLE}
 addUserKnob {20 tab_menu l Feature}
 addUserKnob {22 create_origami_menu l "Create Menu" t "Create a temporary tool menu. Support hotkey. It's not a permanent tool menu. The main purpose is get all the functions with hotkey support." T "p = nuke.Panel('Alert')\np.addNotepad('', 'This menu is temporary and will not override any of personal setting.\\n\\nWhen you \\'Create Menu\\', it might temporary override current hotkey. Please double check \\'Define Hotkey\\' section.\\n\\nUser always able revert hotkey after \\'Remove Menu\\' or restart nuke again.\\n\\nAre you sure to process?')\n\nif p.show() == 1 :\n\toriNAME = nuke.thisGroup().name()\n\thkCrTgt = nuke.thisGroup()\['hk_cr_tgt'].getValue()\n\thkRmTgt = nuke.thisGroup()\['hk_rm_tgt'].getValue()\n\thkCrSrcUI = nuke.thisGroup()\['hk_cr_srcUI'].getValue()\n\thkRmSrcUI = nuke.thisGroup()\['hk_rm_srcUI'].getValue()\n\thkSnap = nuke.thisGroup()\['hk_snap'].getValue()\n\thkDesel = nuke.thisGroup()\['hk_deselect_all'].getValue()\n\thkDeform = nuke.thisGroup()\['hk_deform'].getValue()\n\thkResetD = nuke.thisGroup()\['hk_reset_d'].getValue()\n\n\tmenubar = nuke.menu('Nuke')\n\tori = menubar.addMenu(oriNAME)\n\n\tori.addCommand('Target/Create Target Selection', 'crTgt(oriNAME)', hkCrTgt)\n\tori.addCommand('Target/Remove Target Selection', 'rmTgt(oriNAME)', hkRmTgt)\n\tori.addCommand('Source/Create Source UI', 'crSrcUI(oriNAME)', hkCrSrcUI)\n\tori.addCommand('Source/Remove Source UI', 'rmSrcUI(oriNAME)', hkRmSrcUI)\n\tori.addCommand('Snap Source to Target', 'snap(oriNAME)', hkSnap)\n\tori.addCommand('Deselect All', 'desel(oriNAME)', hkDesel)\n\tori.addCommand('Deform/Deform', 'orideform(oriNAME)', hkDeform)\n\tori.addCommand('Deform/Reset Deform', 'resetD(oriNAME)', hkResetD)\n\n\tdef crTgt(origami) :\n\t\tnuke.toNode(origami)\['create_tgt_set'].execute()\n\n\tdef rmTgt(origami) :\n\t\tnuke.toNode(origami)\['reset_tgt'].execute()\n\n\tdef crSrcUI(origami) :\n\t\tnuke.toNode(origami)\['create_src_set'].execute()\n\n\tdef rmSrcUI(origami) :\n\t\tnuke.toNode(origami)\['reset_src'].execute()\n\n\tdef snap(origami) :\n\t\tnuke.toNode(origami)\['snap'].execute()\n\n\tdef desel(origami) :\n\t\tnuke.toNode(origami)\['deselect_all'].execute()\n\n\tdef orideform(origami) :\n\t\tnuke.toNode(origami)\['deform'].execute()\n\n\tdef resetD(origami) :\n\t\tnuke.toNode(origami)\['reset_deform'].execute()" +STARTLINE}
 addUserKnob {22 remove_origami_menu l "Remove Menu" t "Remove the tool menu" -STARTLINE T "thisNAME = nuke.thisGroup().name()\nnuke.menu('Nuke').removeItem(thisNAME)"}
 addUserKnob {26 title_hotkey l "Define Hotkey"}
 addUserKnob {1 hk_cr_tgt l "Create Target Set"}
 hk_cr_tgt ";"
 addUserKnob {1 hk_rm_tgt l "Remove Target Set"}
 hk_rm_tgt "shift+;"
 addUserKnob {1 hk_cr_srcUI l "Create Source Set"}
 hk_cr_srcUI '
 addUserKnob {1 hk_rm_srcUI l "Remove Source Set"}
 hk_rm_srcUI shift+'
 addUserKnob {1 hk_snap l "Snap Source to Target"}
 hk_snap n
 addUserKnob {1 hk_deselect_all l "Deselect All"}
 hk_deselect_all "\\"
 addUserKnob {1 hk_deform l Deform}
 hk_deform "\["
 addUserKnob {1 hk_reset_d l "Reset Deform"}
 hk_reset_d "]"
 addUserKnob {20 t_VERSION l Version}
 addUserKnob {26 l_VERSION l <b>Version</b> T 1.4}
 addUserKnob {26 l_DATE l "<b>Date Modified</b>" T 2019/03/04}
 addUserKnob {26 l_CHANGELOG l <b>Changelog</b> T "1.4\n- fix the error message on \n  first time run 'Create Target Set'\n  when there has no target input.\n- update warning message\n  for 'Create Menu'\n\n1.3\n- added the function onCreate,\n  when open a script already deform\n  live update will still function.\n\n1.2\n- added card deform option,\n  can get smooth shape of\n  deform with tangent.\n- optimize the tool.\n- added tooltips.\n- layout of panel change.\n- bug fix.\n\n1.1\n- rework entire tool workflow\n  to have better ui and ux"}
 addUserKnob {26 l_DEV l "<b>Developed by</b>" T "Mark Joey Tang"}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0xff
  label "dont touch"
  note_font_size 42
  xpos -2060
  ypos -208
  bdwidth 1011
  bdheight 247
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x4c4c4cff
  label bin
  note_font_size 42
  xpos -2055
  ypos 108
  bdwidth 281
  bdheight 213
 }
 Input {
  inputs 0
  name target
  xpos -370
  ypos -96
 }
 Dot {
  name Dot2
  xpos -336
  ypos 103
 }
 Input {
  inputs 0
  name source
  xpos -526
  ypos -94
  number 1
 }
 Dot {
  name Dot1
  xpos -492
 }
set Na53cea30 [stack 0]
 EditGeo {
  translate {1.379999995 0.7799999714 1.700000167}
  name EditGeo_deform
  xpos -526
  ypos 74
  disable true
 }
 Scene {
  inputs 2
  name oScene
  xpos -516
  ypos 182
 }
 Output {
  name Output1
  xpos -526
  ypos 345
 }
push $Na53cea30
 PythonGeo {
  name pgeoSGet
  xpos -654
  ypos -3
 }
 NoOp {
  inputs 0
  name menu01
  knobChanged "\nthisGRP = nuke.thisGroup()\nif thisGRP\['frame_range'].getValue() == 0 :\n    thisGRP\['firstFR'].setEnabled(False)\n    thisGRP\['lastFR'].setEnabled(False)\nelse :\n    thisGRP\['firstFR'].setEnabled(True)\n    thisGRP\['lastFR'].setEnabled(True)\n"
  xpos -1760
  ypos -86
  addUserKnob {20 User}
  addUserKnob {4 frame_range l "frame range" M {"project setting" custom}}
 }
 NoOp {
  inputs 0
  name menu02
  knobChanged "\nthisGRP = nuke.thisGroup()\nif thisGRP\['live_update'].getValue() == 1 :\n    thisGRP\['update_tangent_setting'].setEnabled(False)\nelse :\n    thisGRP\['update_tangent_setting'].setEnabled(True)\n"
  xpos -1656
  ypos -86
  addUserKnob {20 User}
  addUserKnob {6 live_update l "live update" t "If this knob checked, the tangent value change will update in real-time. Please note that the function works great with static deform. For animated deform, it might take some time to re-calculate every changes.\n\n<b>Recommend :</b>\nTurn this on when looking at reference frame with animation off. Once the deform shape is good, turn this off and deform with animation on again to speed up the process." +STARTLINE}
 }
 NoOp {
  inputs 0
  name targetView3d
  onCreate "\nfor knob in nuke.thisNode().knobs() :\n    try :\n        if knob.split('_')\[3] == 'panelDropped' :\n            nuke.thisNode().removeKnob(nuke.thisNode()\[knob])\n    except :\n        pass\n"
  knobChanged "\nthisGRP = nuke.thisGroup()\ngetColor = thisGRP\['tgt_gl_color'].getValue()\ncolorConvert = '0x%02x%02x%02x%02x' % (getColor\[0]*255 , getColor\[1]*255, getColor\[2]*255, 255)\ntry :\n    axGRP = nuke.toNode('t')\n    axGRP.begin()\n    for node in nuke.allNodes() :\n      if node.Class()\[0:4] == 'Axis' :\n        node\['gl_color'].fromScript(colorConvert)\n    axGRP.end()\nexcept :\n    pass\nfor knob in nuke.thisNode().knobs() :\n    try :\n        if knob.split('_')\[3] == 'panelDropped' :\n            nuke.thisNode().removeKnob(nuke.thisNode()\[knob])\n    except :\n        pass\n"
  xpos -1870
  ypos -86
  addUserKnob {20 User}
  addUserKnob {18 tgt_gl_color l "Target Display Color" t "Display color of the target set in 3D view. Update in real-time."}
  tgt_gl_color {0.1999998093 0 1}
 }
 NoOp {
  inputs 0
  name sourceView3d
  onCreate "\nfor knob in nuke.thisNode().knobs() :\n    try :\n        if knob.split('_')\[3] == 'panelDropped' :\n            nuke.thisNode().removeKnob(nuke.thisNode()\[knob])\n    except :\n        pass\n"
  knobChanged "\nthisGRP = nuke.thisGroup()\ngetColor = thisGRP\['src_gl_color'].getValue()\ncolorConvert = '0x%02x%02x%02x%02x' % (getColor\[0]*255 , getColor\[1]*255, getColor\[2]*255, 255)\ntry :\n    axGRP = nuke.toNode('s')\n    axGRP.begin()\n    for node in nuke.allNodes() :\n      if node.Class()\[0:4] == 'Axis' :\n        node\['gl_color'].fromScript(colorConvert)\n    axGRP.end()\nexcept :\n    pass\nfor knob in nuke.thisNode().knobs() :\n    try :\n        if knob.split('_')\[3] == 'panelDropped' :\n            nuke.thisNode().removeKnob(nuke.thisNode()\[knob])\n    except :\n        pass\n"
  xpos -1981
  ypos -85
  addUserKnob {20 User}
  addUserKnob {18 src_gl_color l "Source Display Color" t "Display color of the source set in 3D view. Update in real-time."}
  src_gl_color {1 0.6000000238 0}
 }
 NoOp {
  inputs 0
  name menu04
  knobChanged "\nif nuke.thisGroup().input(1).Class() == 'Card2' and nuke.thisGroup()\['deform_status'].getValue() == 1 :\n    subdUpdate(nuke.thisGroup(), nuke.thisGroup().input(1))\n"
  xpos -1445
  ypos -86
  addUserKnob {20 User}
  addUserKnob {3 rows l rows/columns t "Increase subdivsion will smooth the geo with curvature shape. The value is applied between each control point. For example, if control points is 3x3, row set to 10. The entire geo subdivision in row will be 30 in total.\n\nThis value will update in real-time after deformed. It will take the control of the source geo, but not adding any custom function."}
  rows 10
  addUserKnob {3 columns l "" t "Increase subdivsion will smooth the geo with curvature shape. The value is applied between each control point. For example, if control points is 3x3, columns set to 10. The entire geo subdivision in columns will be 30 in total.\n\nThis value will update in real-time after deformed. It will take the control of the source geo, but not adding any custom function." -STARTLINE}
  columns 10
 }
 NoOp {
  inputs 0
  name menu03
  knobChanged "\nif nuke.thisGroup().input(1).Class() == 'Card2' and nuke.thisGroup()\['deform_status'].getValue(1) and nuke.thisGroup()\['live_update'].getValue() == 1 :\n    cardCenter( nuke.thisGroup(), nuke.thisGroup().input(1))\n"
  xpos -1554
  ypos -89
  addUserKnob {20 User}
  addUserKnob {7 t1angle l "tangent +x" t "When place the card at origin (0,0,0) , this tangent is control the angle of +x vector direction.\n\n0 is no any tangent angle\n1 is the smoothness angle\n\nValue can be negative or any above 1."}
  t1angle 1
  addUserKnob {7 t1scale l scale t "When place the card at origin (0,0,0) , this tangent is control the scale of +x vector direction.\n\n1 is the normal length of the tangent." -STARTLINE}
  t1scale 1
  addUserKnob {7 t2angle l "tangent -x" t "When place the card at origin (0,0,0) , this tangent is control the angle of -x vector direction.\n\n0 is no any tangent angle\n1 is the smoothness angle\n\nValue can be negative or any above 1."}
  t2angle 1
  addUserKnob {7 t2scale l scale t "When place the card at origin (0,0,0) , this tangent is control the scale of -x vector direction.\n\n1 is the normal length of the tangent." -STARTLINE}
  t2scale 1
  addUserKnob {7 t3angle l "tangent +y" t "When place the card at origin (0,0,0) , this tangent is control the angle of +y vector direction.\n\n0 is no any tangent angle\n1 is the smoothness angle\n\nValue can be negative or any above 1."}
  t3angle 1
  addUserKnob {7 t3scale l scale t "When place the card at origin (0,0,0) , this tangent is control the scale of +y vector direction.\n\n1 is the normal length of the tangent." -STARTLINE}
  t3scale 1
  addUserKnob {7 t4angle l "tangent -y" t "When place the card at origin (0,0,0) , this tangent is control the angle of -y vector direction.\n\n0 is no any tangent angle\n1 is the smoothness angle\n\nValue can be negative or any above 1."}
  t4angle 1
  addUserKnob {7 t4scale l scale t "When place the card at origin (0,0,0) , this tangent is control the scale of -y vector direction.\n\n1 is the normal length of the tangent." -STARTLINE}
  t4scale 1
  addUserKnob {7 edge_tangent l "edge tangent" t "Tangent on the edge can be have a separate value.\n\nIf value = 0 :\nTangent on the edge will not separate than the other. It will take the control from tangent +x/-x/+y/-y\n\nif the value above 0 :\nTangent on the edge will take the value from this knob.\n\nIf want to separate the tangent on the edge but don't want to smooth the geo. User can put 0.01 value to get this work."}
  edge_tangent 0.01
 }
 NoOp {
  inputs 0
  name menu05
  knobChanged "\nthisGRP = nuke.thisGroup()\nif thisGRP\['anim_type_tangent'].getValue() == 0 :\n    thisGRP\['ref_frame'].setEnabled(False)\nelse :\n    thisGRP\['ref_frame'].setEnabled(True)\n"
  xpos -1339
  ypos -88
  addUserKnob {20 User}
  addUserKnob {4 anim_type_tangent l "anim type" t "Anim type of tangent will ONLY apply on <b>deform with animation</b> .\n\n<b>dynamic</b>\nCalculate every tangent angle and length on every frame.\n\n<b>static</b>\nOnly apply the tangent angle and length from the reference frame set in this tool.\n\nWhen the type set to static, <b>reference frame</b> knob will be enable.\n\nThis knob will not trigger 'live update' due to static option require within frame range." M {dynamic static "" "" "" "" "" ""}}
 }
 ModifyMetaData {
  inputs 0
  name dataset
  xpos -2020
  ypos 231
  addUserKnob {20 User}
  addUserKnob {43 raw_cdd l "raw CDD"}
 }
 NoOp {
  inputs 0
  name store
  xpos -1908
  ypos 233
  addUserKnob {20 User}
  addUserKnob {1 filter3DNodes}
  filter3DNodes Axis,Axis2,Card,Card2,Cube,Cylinder,Sphere,ReadGeo,ReadGeo2,Light,Light2,DirectLight,Spotlight,Environment,TransformGeo,EditGeo,Camera,Camera2
  addUserKnob {22 fn T "def getLevel() :\n  ### level define ###\n  if len(nuke.thisNode().fullName().split('.')) == 1 :\n      ggLevel = nuke.root()\n  else :\n      nodePath = nuke.thisNode().fullName().split('.')\n      nodePath.pop()\n      ggLevel = nuke.toNode('.'.join(nodePath))\n  return ggLevel\n\n#######################################################\n\ndef pgVertexPack(pgNode) :\n  pygeoNODE = pgNode\n  vertexKeys = \[]\n  vertexValues = \[]\n\n  for i in pygeoNODE\['geo'].getGeometry()\[0].primitives() :\n    for h in range (0, len(i)) :\n      if vertexKeys.count(i\[h]) == 0 :\n        vertexKeys.append(i\[h])\n\n  for i in range  (0, int(len(pygeoNODE\['geo'].getGeometry()\[0].points())/3)) :\n    vertexValues.append(pygeoNODE\['geo'].getGeometry()\[0].points()\[3*i:3*(i+1)])\n\n  return dict(zip(vertexKeys, vertexValues))\n\n#######################################################\n\ndef getData(metaNODE) :\n  import re\n  tempKeep = re.split('\{set|\}| |\\n',metaNODE\['metadata'].toScript())\n  tempKeep2 = \[]\n  for i in range (0, len(tempKeep), 1) :\n    if len(tempKeep\[i]) != 0 :\n      tempKeep2.append(tempKeep\[i])\n\n  dataset = \{\}\n  for i in range (0, int(len(tempKeep2)/2)) :\n    dataset\[tempKeep2\[2*i]] = tempKeep2\[(2*i)+1]\n  return dataset\n\n#######################################################\n\ndef getCTRLPTS(cdd) :\n  import re\n  tempData01 = re.split('\{|\}|\\\\n| ', cdd)\[6:]\n  tempData02 = \[]\n  for i in tempData01 :\n      if len(i) != 0 :\n          tempData02.append(float(i))\n  del tempData01\n\n  tempData01 = \[]\n  for i in range (0, len(tempData02)) :\n    if i%24 > 0 and i%24 < 4 :\n      tempData01.append(tempData02\[i])\n\n  del tempData02\n\n  cpt = \[]\n  for i in range (0, int(len(tempData01)/3) ) :\n    cpt.append(tempData01\[i*3:(i*3)+3])\n\n  return cpt\n\n#######################################################\n\ndef targetLock(tgtNODE) :\n  #thisNODE = nuke.thisNode()\n  thisNAME = tgtNODE.fullName()\n  grpPath = '.'.join(thisNAME.split('.')\[:-1])\n  pos = tgtNODE\['origin'].getValue()\n  grpNODE = nuke.toNode(grpPath)\n  grpNODE.begin()\n  for node in nuke.allNodes() :\n    if node.fullName() != thisNAME :\n      node\['selected'].setValue(0)\n      tgtNODE\['translate'].setValue(pos)\n  grpNODE.end()\n\n#######################################################\n\ndef createSRCset(vdata, mtx, getColorNode) :\n  srcGRP = nuke.nodes.Group(name='s')\n  getColor = getColorNode\['src_gl_color'].getValue()\n\n  deform = nuke.toNode('EditGeo_deform')\n  oScene = nuke.toNode('oScene')\n\n  srcGRP.begin()\n  srcSC = nuke.nodes.Scene()\n  srcOUT = nuke.nodes.Output()\n  srcOUT.setInput(0, srcSC)\n\n  for key in vdata :\n    srcAX = nuke.nodes.Axis(name='y' + str(key))\n    srcAX.addKnob(nuke.XYZ_Knob('origin'))\n    srcAX\['translate'].setValue((vdata\[key]\[0]*mtx\[0]+vdata\[key]\[1]*mtx\[1]+vdata\[key]\[2]*mtx\[2])+mtx\[3], 0)\n    srcAX\['translate'].setValue((vdata\[key]\[0]*mtx\[4]+vdata\[key]\[1]*mtx\[5]+vdata\[key]\[2]*mtx\[6])+mtx\[7], 1)\n    srcAX\['translate'].setValue((vdata\[key]\[0]*mtx\[8]+vdata\[key]\[1]*mtx\[9]+vdata\[key]\[2]*mtx\[10])+mtx\[11], 2)\n    srcAX\['origin'].setValue((vdata\[key]\[0]*mtx\[0]+vdata\[key]\[1]*mtx\[1]+vdata\[key]\[2]*mtx\[2])+mtx\[3], 0)\n    srcAX\['origin'].setValue((vdata\[key]\[0]*mtx\[4]+vdata\[key]\[1]*mtx\[5]+vdata\[key]\[2]*mtx\[6])+mtx\[7], 1)\n    srcAX\['origin'].setValue((vdata\[key]\[0]*mtx\[8]+vdata\[key]\[1]*mtx\[9]+vdata\[key]\[2]*mtx\[10])+mtx\[11], 2)\n    srcAX\['scaling'].setExpression('parent.parent.src_scale')\n    srcAX\['gl_color'].fromScript('0x%02x%02x%02x%02x' % (getColor\[0]*255 , getColor\[1]*255, getColor\[2]*255, 255))\n    srcSC.setInput(key, srcAX)\n  srcGRP.end()\n\n  del mtx\n\n  oScene.setInput(2, srcGRP)\n\n  dkeys = \[]\n  dvalues = \[] \n\n  for key in vdata :\n    dkeys.append(str(key))\n    for i in range (0, 3) :\n      dvalues.append(str(0.0))\n\n  deform\['keys'].fromScript('\{' + ' '.join(dkeys) + '\}')\n  deform\['values'].fromScript('\{' + ' '.join(dvalues) + '\}')\n\n#######################################################\n\ndef sssAngle(vec1, vec2, vec3) :\n  import math\n  ### get 3 sides length ###\n  lA = math.sqrt( math.pow(vec3\[0] - vec1\[0], 2) + math.pow(vec3\[1] - vec1\[1], 2) + math.pow(vec3\[2] - vec1\[2], 2) )\n  lB = math.sqrt( math.pow(vec2\[0] - vec1\[0], 2) + math.pow(vec2\[1] - vec1\[1], 2) + math.pow(vec2\[2] - vec1\[2], 2) )\n  lC = math.sqrt( math.pow(vec2\[0] - vec3\[0], 2) + math.pow(vec2\[1] - vec3\[1], 2) + math.pow(vec2\[2] - vec3\[2], 2) )\n\n  try :\n    output = math.degrees( math.acos( ( math.pow(lA,2) + math.pow(lB,2) - math.pow(lC,2) ) / (2 * lA * lB) ) )\n  except ValueError :\n    output = 0\n\n  return output\n\n#######################################################\n\ndef modPRot(tri) :\n  import math\n  a = tri\[1] - tri\[0] \n  b = tri\[2] - tri\[0] \n  \n  u = nuke.math.Vector3(a) \n  u.normalize() \n  w = a.cross(b) \n  w.normalize() \n  v = w.cross(u)\n\n  bias = 0.01\n\n  m = ( (u\[0], v\[0], w\[0]), (u\[1], v\[1], w\[1]), (u\[2], v\[2], w\[2]) ) \n  if abs(m\[1]\[2]) > 1-bias and abs(m\[1]\[2]) < 1+bias :\n    ry = 0.0 \n    rx = (math.pi / 2.0) * -m\[1]\[2] \n    rz = math.atan2(-m\[0]\[1], m\[0]\[0])      \n  else: \n    cosx = math.sqrt(m\[0]\[2] ** 2 + m\[2]\[2] ** 2) \n    if cosx == 0: \n      cosx = 1.0 \n    rx = math.atan2(-m\[1]\[2], cosx) \n    rz = math.atan2(m\[1]\[0] / cosx, m\[1]\[1] / cosx) \n    ry = math.atan2(m\[0]\[2] / cosx, m\[2]\[2] / cosx)\n\n  return nuke.math.Vector3(rx, ry, rz) \n\n#######################################################\n\ndef tvar(vec1, vec2, vec3, calangle, tangle, tscale) :\n  import math\n  tangentLength = vec1.distanceBetween(vec2)/3 * tscale\n  rot = \[ math.degrees(modPRot((vec1, vec2, vec3))\[0]), math.degrees(modPRot((vec1, vec2, vec3))\[1]), math.degrees(modPRot((vec1, vec2, vec3))\[2]) + (calangle*-tangle) ]\n\n  return \[ tangentLength * ( math.cos(math.radians(rot\[1])) * math.cos(math.radians(rot\[2])) + math.sin(math.radians(rot\[1])) * math.sin(math.radians(rot\[0])) * math.sin(math.radians(rot\[2])) ), tangentLength * ( math.cos(math.radians(rot\[0])) * math.sin(math.radians(rot\[2])) ), tangentLength * ( -math.sin(math.radians(rot\[1])) * math.cos(math.radians(rot\[2])) + math.cos(math.radians(rot\[1])) * math.sin(math.radians(rot\[0])) * math.sin(math.radians(rot\[2])) ) ]\n\n#######################################################\n\ndef cardCenter(getNode, srcNode) :\n  try :\n\t  datasetNODE = nuke.toNode('dataset')\n\n\t  wSub = int(datasetNODE\['raw_cdd'].getValue().split(' ')\[2])\n\t  hSub = int(datasetNODE\['raw_cdd'].getValue().split(' ')\[1])\n\t  totalcpts = wSub*hSub\n\n\t  if wSub <= 2 or hSub <= 2 :\n\t    nuke.message('Please set deform points at least 3x3.')\n\t  else :\n\t    srcNode\['useMatrix'].setValue(0)\n\t    srcMTX = srcNode\['matrix'].getValue()\n\t    srcNode\['useMatrix'].setValue(1)\n\t    srcNode\['matrix'].setValue(\[1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0])\n\t    \n\t    import re\n\t    raw_cdd = re.split( '\{|\}', datasetNODE\['raw_cdd'].toScript() )\n\n\t    FRsetting = getNode\['frame_range'].getValue()\n\n\t    if FRsetting == 1 :\n\t      frameST = int(getNode\['firstFR'].getValue())\n\t      frameED = int(getNode\['lastFR'].getValue())\n\t    else :\n\t      frameST = nuke.root().firstFrame()\n\t      frameED = nuke.root().lastFrame()\n\n\t    wAnim = getNode\['deform_anim'].getValue()\n\n\t    md = getData(getNode)\n\t    metaNum = \[]\n\t    for key in md :\n\t      metaNum.append( int(key\[3:]) )\n\n\t    ##########################################\n\n\t    cptsData = \{\n\t      'newPosX': \[], \n\t      'newPosY': \[], \n\t      'newPosZ': \[], \n\t      't1X': \[], \n\t      't1Y': \[], \n\t      't1Z': \[], \n\t      't2X': \[], \n\t      't2Y': \[], \n\t      't2Z': \[], \n\t      't3X': \[], \n\t      't3Y': \[], \n\t      't3Z': \[], \n\t      't4X': \[], \n\t      't4Y': \[], \n\t      't4Z': \[], \n\t      'uvX': \[], \n\t      'uvY': \[], \n\t      'uvZ': \[],\n\t      \}\n\n\t    if wAnim == 0 :\n\t      for i in range(totalcpts) :\n\t        if metaNum.count(i) == 1 :\n\t          cptsData\['newPosX'].append(str(nuke.toNode(md\['s.y'+str(i)])\['translate'].getValue()\[0]))\n\t          cptsData\['newPosY'].append(str(nuke.toNode(md\['s.y'+str(i)])\['translate'].getValue()\[1]))\n\t          cptsData\['newPosZ'].append(str(nuke.toNode(md\['s.y'+str(i)])\['translate'].getValue()\[2]))\n\t        else :\n\t          cptsData\['newPosX'].append(str((float(raw_cdd\[1::12]\[i].split(' ')\[0])*srcMTX\[0] + float(raw_cdd\[1::12]\[i].split(' ')\[1])*srcMTX\[1] + float(raw_cdd\[1::12]\[i].split(' ')\[2])*srcMTX\[2])+srcMTX\[3]))\n\t          cptsData\['newPosY'].append(str((float(raw_cdd\[1::12]\[i].split(' ')\[0])*srcMTX\[4] + float(raw_cdd\[1::12]\[i].split(' ')\[1])*srcMTX\[5] + float(raw_cdd\[1::12]\[i].split(' ')\[2])*srcMTX\[6])+srcMTX\[7]))\n\t          cptsData\['newPosZ'].append(str((float(raw_cdd\[1::12]\[i].split(' ')\[0])*srcMTX\[8] + float(raw_cdd\[1::12]\[i].split(' ')\[1])*srcMTX\[9] + float(raw_cdd\[1::12]\[i].split(' ')\[2])*srcMTX\[10])+srcMTX\[11]))\n\t  \n\t      for i in range(totalcpts) :\n\t        vec1 = nuke.math.Vector3()\n\t        vec2 = nuke.math.Vector3()\n\t        vec3 = nuke.math.Vector3()\n\n\t      ### t1 ###\n\n\t        vec1.set( float(cptsData\['newPosX']\[i]), float(cptsData\['newPosY']\[i]), float(cptsData\['newPosZ']\[i]) )\n\n\t        if i%wSub != wSub-1 :\n\t          vec2.set( float(cptsData\['newPosX']\[i+1]), float(cptsData\['newPosY']\[i+1]), float(cptsData\['newPosZ']\[i+1]) )\n\t          \n\t          if i%wSub == 0 :\n\t            vec3.set( float(cptsData\['newPosX']\[i+2]), float(cptsData\['newPosY']\[i+2]), float(cptsData\['newPosZ']\[i+2]) )\n\t            if getNode\['edge_tangent'].getValue() == 0 :\n\t              angle = 45\n\t            else :\n\t              angle = 45 * getNode\['edge_tangent'].getValue()\n\t          else :\n\t            vec3.set( float(cptsData\['newPosX']\[i-1]), float(cptsData\['newPosY']\[i-1]), float(cptsData\['newPosZ']\[i-1]) )\n\t            angle = sssAngle(vec2, vec3, vec1)\n\n\t          cptsData\['t1X'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t1angle'].getValue(), getNode\['t1scale'].getValue())\[0] ) )\n\t          cptsData\['t1Y'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t1angle'].getValue(), getNode\['t1scale'].getValue())\[1] ) )\n\t          cptsData\['t1Z'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t1angle'].getValue(), getNode\['t1scale'].getValue())\[2] ) )\n\t        else :\n\t          cptsData\['t1X'].append('0')\n\t          cptsData\['t1Y'].append('0')\n\t          cptsData\['t1Z'].append('0')\n\n\t      ### t2 ###\n\n\t        if i%wSub != 0 :\n\t          vec2.set( float(cptsData\['newPosX']\[i-1]), float(cptsData\['newPosY']\[i-1]), float(cptsData\['newPosZ']\[i-1]) )\n\t          \n\t          if i%wSub == wSub-1 :\n\t            vec3.set( float(cptsData\['newPosX']\[i-2]), float(cptsData\['newPosY']\[i-2]), float(cptsData\['newPosZ']\[i-2]) )\n\t            if getNode\['edge_tangent'].getValue() == 0 :\n\t              angle = 45\n\t            else :\n\t              angle = 45 * getNode\['edge_tangent'].getValue()\n\t          else :\n\t            vec3.set( float(cptsData\['newPosX']\[i+1]), float(cptsData\['newPosY']\[i+1]), float(cptsData\['newPosZ']\[i+1]) )\n\t            angle = sssAngle(vec2, vec3, vec1)\n\n\t          cptsData\['t2X'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t2angle'].getValue(), getNode\['t2scale'].getValue())\[0] ) )\n\t          cptsData\['t2Y'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t2angle'].getValue(), getNode\['t2scale'].getValue())\[1] ) )\n\t          cptsData\['t2Z'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t2angle'].getValue(), getNode\['t2scale'].getValue())\[2] ) )\n\t        else :\n\t          cptsData\['t2X'].append('0')\n\t          cptsData\['t2Y'].append('0')\n\t          cptsData\['t2Z'].append('0')\n\n\t      ### t3 ###\n\n\t        if i < totalcpts-wSub :\n\t          vec2.set( float(cptsData\['newPosX']\[i+wSub]), float(cptsData\['newPosY']\[i+wSub]), float(cptsData\['newPosZ']\[i+wSub]) )\n\t          \n\t          if i < wSub :\n\t            vec3.set( float(cptsData\['newPosX']\[i+wSub*2]), float(cptsData\['newPosY']\[i+wSub*2]), float(cptsData\['newPosZ']\[i+wSub*2]) )\n\t            if getNode\['edge_tangent'].getValue() == 0 :\n\t              angle = 45\n\t            else :\n\t              angle = 45 * getNode\['edge_tangent'].getValue()\n\t          else :\n\t            vec3.set( float(cptsData\['newPosX']\[i-wSub]), float(cptsData\['newPosY']\[i-wSub]), float(cptsData\['newPosZ']\[i-wSub]) )\n\t            angle = sssAngle(vec2, vec3, vec1)\n\n\t          cptsData\['t3X'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t3angle'].getValue(), getNode\['t3scale'].getValue())\[0] ) )\n\t          cptsData\['t3Y'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t3angle'].getValue(), getNode\['t3scale'].getValue())\[1] ) )\n\t          cptsData\['t3Z'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t3angle'].getValue(), getNode\['t3scale'].getValue())\[2] ) )\n\t        else :\n\t          cptsData\['t3X'].append('0')\n\t          cptsData\['t3Y'].append('0')\n\t          cptsData\['t3Z'].append('0')\n\n\t      ### t4 ###\n\n\t        if i >= wSub :\n\t          vec2.set( float(cptsData\['newPosX']\[i-wSub]), float(cptsData\['newPosY']\[i-wSub]), float(cptsData\['newPosZ']\[i-wSub]) )\n\t          \n\t          if i >= totalcpts-wSub :\n\t            vec3.set( float(cptsData\['newPosX']\[i-wSub*2]), float(cptsData\['newPosY']\[i-wSub*2]), float(cptsData\['newPosZ']\[i-wSub*2]) )\n\t            if getNode\['edge_tangent'].getValue() == 0 :\n\t              angle = 45\n\t            else :\n\t              angle = 45 * getNode\['edge_tangent'].getValue()\n\t          else :\n\t            vec3.set( float(cptsData\['newPosX']\[i+wSub]), float(cptsData\['newPosY']\[i+wSub]), float(cptsData\['newPosZ']\[i+wSub]) )\n\t            angle = sssAngle(vec2, vec3, vec1)\n\n\t          cptsData\['t4X'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t4angle'].getValue(), getNode\['t4scale'].getValue())\[0] ) )\n\t          cptsData\['t4Y'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t4angle'].getValue(), getNode\['t4scale'].getValue())\[1] ) )\n\t          cptsData\['t4Z'].append( str( tvar(vec1, vec2, vec3, angle, getNode\['t4angle'].getValue(), getNode\['t4scale'].getValue())\[2] ) )\n\t        else :\n\t          cptsData\['t4X'].append('0')\n\t          cptsData\['t4Y'].append('0')\n\t          cptsData\['t4Z'].append('0')\n\n\t      ### UV ###  \n\n\t      for i in xrange (0, int(len(raw_cdd)/12) ) :\n\t        cptsData\['uvX'].append(str(raw_cdd\[(i*12)+11].split(' ')\[0]) )\n\t        cptsData\['uvY'].append(str(raw_cdd\[(i*12)+11].split(' ')\[1]) )\n\t        cptsData\['uvZ'].append(str(raw_cdd\[(i*12)+11].split(' ')\[2]) )\n\n\t      ##########################################\n\t  \n\t      posData = \['1 \{' + cptsData\['newPosX']\[i] + ' ' + cptsData\['newPosY']\[i] + ' ' + cptsData\['newPosZ']\[i] + '\} 1 \{' + cptsData\['t1X']\[i] + ' ' + cptsData\['t1Y']\[i] + ' ' + cptsData\['t1Z']\[i] + '\} 1 \{' + cptsData\['t2X']\[i] + ' ' + cptsData\['t2Y']\[i] + ' ' + cptsData\['t2Z']\[i] + '\} 1 \{' + cptsData\['t3X']\[i] + ' ' + cptsData\['t3Y']\[i] + ' ' + cptsData\['t3Z']\[i] + '\} 1 \{' + cptsData\['t4X']\[i] + ' ' + cptsData\['t4Y']\[i] + ' ' + cptsData\['t4Z']\[i] + '\} 0 \{' + cptsData\['uvX']\[i] + ' ' + cptsData\['uvY']\[i] + ' ' + cptsData\['uvZ']\[i] + '\}' for i in range(totalcpts)]\n\t      posData.insert(0, str(datasetNODE\['raw_cdd'].getValue().split(' ')\[0]) + ' ' + str(datasetNODE\['raw_cdd'].getValue().split(' ')\[1]) + ' ' + str(datasetNODE\['raw_cdd'].getValue().split(' ')\[2]) + ' ' +str(datasetNODE\['raw_cdd'].getValue().split(' ')\[3]) + '\\n')\n\n\t      srcNode\['control_points'].fromScript( '\\n'.join(posData) )\n\t      srcNode\['label'].setValue('Deform by Origami')\n\t      srcNode\['tile_color'].fromScript(getNode\['tile_color'].toScript())\n\n\t      del cptsData, vec1, vec2, vec3, angle, posData\n\n\t    else :\n\n\t      progBar = nuke.ProgressTask('Calculating')\n\t      jobCount = 0\n\t      jobTotal = (frameED-frameST) + 1\n\n\t      for time in xrange (int(frameST), int(frameED+1), 1) :\n\n\t        ### progress bar\n\t        jobCount += 1\n\t        progShow = int(jobCount/jobTotal * 100)\n\t        if progBar.isCancelled() :\n\t          break;\n\t        progBar.setProgress(progShow)\n\t        #################\n\n\t        tRange = (totalcpts*(time-frameST))\n\n\t        for i in range(totalcpts) :\n\t          if metaNum.count(i) == 1 : \n\t            cptsData\['newPosX'].append('x' + str(time) + ' ' + str(nuke.toNode(md\['s.y'+str(i)])\['translate'].getValueAt(time)\[0]))\n\t            cptsData\['newPosY'].append('x' + str(time) + ' ' + str(nuke.toNode(md\['s.y'+str(i)])\['translate'].getValueAt(time)\[1]))\n\t            cptsData\['newPosZ'].append('x' + str(time) + ' ' + str(nuke.toNode(md\['s.y'+str(i)])\['translate'].getValueAt(time)\[2]))\n\t          else :\n\t            cptsData\['newPosX'].append('x' + str(time) + ' ' + str((float(raw_cdd\[1::12]\[i].split(' ')\[0])*srcMTX\[0] + float(raw_cdd\[1::12]\[i].split(' ')\[1])*srcMTX\[1] + float(raw_cdd\[1::12]\[i].split(' ')\[2])*srcMTX\[2])+srcMTX\[3]))\n\t            cptsData\['newPosY'].append('x' + str(time) + ' ' + str((float(raw_cdd\[1::12]\[i].split(' ')\[0])*srcMTX\[4] + float(raw_cdd\[1::12]\[i].split(' ')\[1])*srcMTX\[5] + float(raw_cdd\[1::12]\[i].split(' ')\[2])*srcMTX\[6])+srcMTX\[7]))\n\t            cptsData\['newPosZ'].append('x' + str(time) + ' ' + str((float(raw_cdd\[1::12]\[i].split(' ')\[0])*srcMTX\[8] + float(raw_cdd\[1::12]\[i].split(' ')\[1])*srcMTX\[9] + float(raw_cdd\[1::12]\[i].split(' ')\[2])*srcMTX\[10])+srcMTX\[11]))\n\n\t        for i in range(totalcpts) :\n\t          vec1 = nuke.math.Vector3()\n\t          vec2 = nuke.math.Vector3()\n\t          vec3 = nuke.math.Vector3()\n\n\t        ### t1 ###\n\n\t          vec1.set( float(cptsData\['newPosX']\[i+tRange].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange].split(' ')\[1]) )\n\n\t          if i%wSub != wSub-1 :\n\t            vec2.set( float(cptsData\['newPosX']\[i+tRange+1].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange+1].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange+1].split(' ')\[1]) )\n\t            \n\t            if i%wSub == 0 :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange+2].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange+2].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange+2].split(' ')\[1]) )\n\t              if getNode\['edge_tangent'].getValueAt(time) == 0 :\n\t                angle = 45\n\t              else :\n\t                angle = 45 * getNode\['edge_tangent'].getValueAt(time)\n\t            else :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange-1].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange-1].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange-1].split(' ')\[1]) )\n\t              angle = sssAngle(vec2, vec3, vec1)\n\n\t            cptsData\['t1X'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t1angle'].getValueAt(time), getNode\['t1scale'].getValueAt(time))\[0] ))\n\t            cptsData\['t1Y'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t1angle'].getValueAt(time), getNode\['t1scale'].getValueAt(time))\[1] ))\n\t            cptsData\['t1Z'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t1angle'].getValueAt(time), getNode\['t1scale'].getValueAt(time))\[2] ))\n\t          else :\n\t            cptsData\['t1X'].append('x' + str(time) + ' 0')\n\t            cptsData\['t1Y'].append('x' + str(time) + ' 0')\n\t            cptsData\['t1Z'].append('x' + str(time) + ' 0')\n\n\t        ### t2 ###\n\n\t          if i%wSub != 0 :\n\t            vec2.set( float(cptsData\['newPosX']\[i+tRange-1].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange-1].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange-1].split(' ')\[1]) )\n\t            \n\t            if i%wSub == wSub-1 :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange-2].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange-2].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange-2].split(' ')\[1]) )\n\t              if getNode\['edge_tangent'].getValueAt(time) == 0 :\n\t                angle = 45\n\t              else :\n\t                angle = 45 * getNode\['edge_tangent'].getValueAt(time)\n\t            else :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange+1].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange+1].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange+1].split(' ')\[1]) )\n\t              angle = sssAngle(vec2, vec3, vec1)\n\n\t            cptsData\['t2X'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t2angle'].getValueAt(time), getNode\['t2scale'].getValueAt(time))\[0] ))\n\t            cptsData\['t2Y'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t2angle'].getValueAt(time), getNode\['t2scale'].getValueAt(time))\[1] ))\n\t            cptsData\['t2Z'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t2angle'].getValueAt(time), getNode\['t2scale'].getValueAt(time))\[2] ))\n\t          else :\n\t            cptsData\['t2X'].append('x' + str(time) + ' 0')\n\t            cptsData\['t2Y'].append('x' + str(time) + ' 0')\n\t            cptsData\['t2Z'].append('x' + str(time) + ' 0')\n\n\t        ### t3 ###\n\t    \n\t          if i < totalcpts-wSub :\n\t            vec2.set( float(cptsData\['newPosX']\[i+tRange+wSub].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange+wSub].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange+wSub].split(' ')\[1]) )\n\t            \n\t            if i < wSub :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange+wSub*2].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange+wSub*2].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange+wSub*2].split(' ')\[1]) )\n\t              if getNode\['edge_tangent'].getValueAt(time) == 0 :\n\t                angle = 45\n\t              else :\n\t                angle = 45 * getNode\['edge_tangent'].getValueAt(time)\n\t            else :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange-wSub].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange-wSub].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange-wSub].split(' ')\[1]) )\n\t              angle = sssAngle(vec2, vec3, vec1)\n\n\t            cptsData\['t3X'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t3angle'].getValueAt(time), getNode\['t3scale'].getValueAt(time))\[0] ))\n\t            cptsData\['t3Y'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t3angle'].getValueAt(time), getNode\['t3scale'].getValueAt(time))\[1] ))\n\t            cptsData\['t3Z'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t3angle'].getValueAt(time), getNode\['t3scale'].getValueAt(time))\[2] ))\n\t          else :\n\t            cptsData\['t3X'].append('x' + str(time) + ' 0')\n\t            cptsData\['t3Y'].append('x' + str(time) + ' 0')\n\t            cptsData\['t3Z'].append('x' + str(time) + ' 0')\n\n\t        ### t4 ###\n\n\t          if i >= wSub :\n\t            vec2.set( float(cptsData\['newPosX']\[i+tRange-wSub].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange-wSub].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange-wSub].split(' ')\[1]) )\n\t            \n\t            if i >= totalcpts-wSub :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange-wSub*2].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange-wSub*2].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange-wSub*2].split(' ')\[1]) )\n\t              if getNode\['edge_tangent'].getValueAt(time) == 0 :\n\t                angle = 45\n\t              else :\n\t                angle = 45 * getNode\['edge_tangent'].getValueAt(time)\n\t            else :\n\t              vec3.set( float(cptsData\['newPosX']\[i+tRange+wSub].split(' ')\[1]), float(cptsData\['newPosY']\[i+tRange+wSub].split(' ')\[1]), float(cptsData\['newPosZ']\[i+tRange+wSub].split(' ')\[1]) )\n\t              angle = sssAngle(vec2, vec3, vec1)\n\n\t            cptsData\['t4X'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t4angle'].getValueAt(time), getNode\['t4scale'].getValueAt(time))\[0] ))\n\t            cptsData\['t4Y'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t4angle'].getValueAt(time), getNode\['t4scale'].getValueAt(time))\[1] ))\n\t            cptsData\['t4Z'].append('x' + str(time) + ' ' + str( tvar(vec1, vec2, vec3, angle, getNode\['t4angle'].getValueAt(time), getNode\['t4scale'].getValueAt(time))\[2] ))\n\t          else :\n\t            cptsData\['t4X'].append('x' + str(time) + ' 0')\n\t            cptsData\['t4Y'].append('x' + str(time) + ' 0')\n\t            cptsData\['t4Z'].append('x' + str(time) + ' 0')\n\n\t        ### UV ###  \n\n\t        if time == frameST :\n\t          for i in xrange (0, int(len(raw_cdd)/12) ) :\n\t            cptsData\['uvX'].append( 'x' + str(time) + ' ' + str(raw_cdd\[(i*12)+11].split(' ')\[0]) )\n\t            cptsData\['uvY'].append( 'x' + str(time) + ' ' + str(raw_cdd\[(i*12)+11].split(' ')\[1]) )\n\t            cptsData\['uvZ'].append( 'x' + str(time) + ' ' + str(raw_cdd\[(i*12)+11].split(' ')\[2]) )\n\n\t      ##########################################\n\n\t      if getNode\['anim_type_tangent'].getValue() == 0 :\n\t        posData = \['1 \{\{curve ' + ' '.join(cptsData\['newPosX']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['newPosY']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['newPosZ']\[i::totalcpts]) + '\}\} 1 \{\{curve ' + ' '.join(cptsData\['t1X']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t1Y']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t1Z']\[i::totalcpts]) + '\}\} 1 \{\{curve ' + ' '.join(cptsData\['t2X']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t2Y']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t2Z']\[i::totalcpts]) + '\}\} 1 \{\{curve ' + ' '.join(cptsData\['t3X']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t3Y']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t3Z']\[i::totalcpts]) + '\}\} 1 \{\{curve ' + ' '.join(cptsData\['t4X']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t4Y']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['t4Z']\[i::totalcpts]) + '\}\} 0 \{\{curve ' + cptsData\['uvX']\[i] + '\} \{curve ' + cptsData\['uvY']\[i] + '\} \{curve ' + cptsData\['uvZ']\[i] + '\}\}' for i in range(totalcpts)]\n\t      else :\n\t        selFR = totalcpts*(int(getNode\['ref_frame'].getValue()-frameST))\n\t        posData = \['1 \{\{curve ' + ' '.join(cptsData\['newPosX']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['newPosY']\[i::totalcpts]) + '\} \{curve ' + ' '.join(cptsData\['newPosZ']\[i::totalcpts]) + '\}\} 1 \{\{curve ' + cptsData\['t1X']\[i+selFR] + '\} \{curve ' + cptsData\['t1Y']\[i+selFR] + '\} \{curve ' + cptsData\['t1Z']\[i+selFR] + '\}\} 1 \{\{curve ' + cptsData\['t2X']\[i+selFR] + '\} \{curve ' + cptsData\['t2Y']\[i+selFR] + '\} \{curve ' + cptsData\['t2Z']\[i+selFR] + '\}\} 1 \{\{curve ' + cptsData\['t3X']\[i+selFR] + '\} \{curve ' + cptsData\['t3Y']\[i+selFR] + '\} \{curve ' + cptsData\['t3Z']\[i+selFR] + '\}\} 1 \{\{curve ' + cptsData\['t4X']\[i+selFR] + '\} \{curve ' + cptsData\['t4Y']\[i+selFR] + '\} \{curve ' + cptsData\['t4Z']\[i+selFR] + '\}\} 0 \{\{curve ' + cptsData\['uvX']\[i] + '\} \{curve ' + cptsData\['uvY']\[i] + '\} \{curve ' + cptsData\['uvZ']\[i] + '\}\}' for i in range(totalcpts)]\n\t        del selFR\n\t      \n\t      posData.insert(0, str(datasetNODE\['raw_cdd'].getValue().split(' ')\[0]) + ' ' + str(datasetNODE\['raw_cdd'].getValue().split(' ')\[1]) + ' ' + str(datasetNODE\['raw_cdd'].getValue().split(' ')\[2]) + ' ' +str(datasetNODE\['raw_cdd'].getValue().split(' ')\[3]) + '\\n')\n\n\t      srcNode\['control_points'].fromScript( '\\n'.join(posData) )\n\t      srcNode\['label'].setValue('Deform by Origami')\n\t      srcNode\['tile_color'].fromScript(getNode\['tile_color'].toScript())\n\n\t      del progBar\n\t      del cptsData, vec1, vec2, vec3, angle, #posData\n  except IndexError :\n    nuke.message('Cannot process. The <font color=orange>reference frame</font> of static tangent animation is not within the frame range.\\n\\nSuggestion:\\n- fix the reference frame within frame range.\\n- change anim type of tangent to dynamic.')\n\n#######################################################\n\ndef subdUpdate(getNode, srcNode) :\n  try :\n    srcNode\['rows'].setValue(getNode\['rows'].getValue())\n    srcNode\['columns'].setValue(getNode\['columns'].getValue())\n  except TypeError :\n    nuke.message('Missing source input.')\n\n#######################################################\n\ndef cardTest(id, mainPts, roX, roY, roZ) :\n  root = nuke.root()\n\n  root.begin()\n  ca = nuke.nodes.Card(name='x' + str(id))\n  ca\['translate'].setValue(mainPts)\n  ca\['rotate'].setValue( roX, 0)\n  ca\['rotate'].setValue( roY, 1)\n  ca\['rotate'].setValue( roZ, 2)\n  ca\['uniform_scale'].setValue(2)\n  root.end()" +STARTLINE}
 }
end_group
